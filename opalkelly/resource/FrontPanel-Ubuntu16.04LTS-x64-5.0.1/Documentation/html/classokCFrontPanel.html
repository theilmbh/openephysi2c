<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>FrontPanel API: okCFrontPanel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="OpalKellyAPI.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_tiny.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FrontPanel API
   &#160;<span id="projectnumber">5.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classokCFrontPanel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">okCFrontPanel Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class encapsulates the functionality of an Opal Kelly FrontPanel-enabled device including FPGA configuration, PLL configuration, and FrontPanel endpoint access.  
 <a href="classokCFrontPanel.html#details">More...</a></p>

<p>Inherits okCFrontPanelTypes.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf79b986d6f38115bbe078cddd150eb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf79b986d6f38115bbe078cddd150eb0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#acf79b986d6f38115bbe078cddd150eb0">okCFrontPanel</a> ()</td></tr>
<tr class="memdesc:acf79b986d6f38115bbe078cddd150eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:acf79b986d6f38115bbe078cddd150eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98380d232cc085b18e01dea892c1851e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98380d232cc085b18e01dea892c1851e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a98380d232cc085b18e01dea892c1851e">~okCFrontPanel</a> ()</td></tr>
<tr class="memdesc:a98380d232cc085b18e01dea892c1851e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a98380d232cc085b18e01dea892c1851e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62c291d8dafb39ee722f603c8a1e390"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#ab62c291d8dafb39ee722f603c8a1e390">GetLastErrorMessage</a> () const </td></tr>
<tr class="separator:ab62c291d8dafb39ee722f603c8a1e390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6ecf0224545b1160ca15de62795d27"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a5d6ecf0224545b1160ca15de62795d27">ActivateTriggerIn</a> (int epAddr, int bit)</td></tr>
<tr class="memdesc:a5d6ecf0224545b1160ca15de62795d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates a given trigger.  <a href="#a5d6ecf0224545b1160ca15de62795d27">More...</a><br /></td></tr>
<tr class="separator:a5d6ecf0224545b1160ca15de62795d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee80bc2c65ef4e3d62f230892ad4c9b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#aee80bc2c65ef4e3d62f230892ad4c9b3">Close</a> ()</td></tr>
<tr class="memdesc:aee80bc2c65ef4e3d62f230892ad4c9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the device.  <a href="#aee80bc2c65ef4e3d62f230892ad4c9b3">More...</a><br /></td></tr>
<tr class="separator:aee80bc2c65ef4e3d62f230892ad4c9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba687692ea69eb5d033136b91586d14"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a8ba687692ea69eb5d033136b91586d14">ConfigureFPGA</a> (const std::string strFilename, void(*callback)(int, int, void *)=NULL, void *arg=NULL)</td></tr>
<tr class="memdesc:a8ba687692ea69eb5d033136b91586d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download an FPGA configuration from a file.  <a href="#a8ba687692ea69eb5d033136b91586d14">More...</a><br /></td></tr>
<tr class="separator:a8ba687692ea69eb5d033136b91586d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa6482e470a0e61afacc5bcc9169a0f"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#aeaa6482e470a0e61afacc5bcc9169a0f">ConfigureFPGAWithReset</a> (const std::string strFilename, const <a class="el" href="structokTFPGAResetProfile.html">okTFPGAResetProfile</a> *reset, void(*callback)(int, int, void *)=NULL, void *arg=NULL)</td></tr>
<tr class="memdesc:aeaa6482e470a0e61afacc5bcc9169a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download an FPGA configuration from a file and reset.  <a href="#aeaa6482e470a0e61afacc5bcc9169a0f">More...</a><br /></td></tr>
<tr class="separator:aeaa6482e470a0e61afacc5bcc9169a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464b5f9ea9daaf58d6d8a6212d515283"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a464b5f9ea9daaf58d6d8a6212d515283">ConfigureFPGAFromMemory</a> (const unsigned char *data, unsigned long length, void(*callback)(int, int, void *)=NULL, void *arg=NULL)</td></tr>
<tr class="memdesc:a464b5f9ea9daaf58d6d8a6212d515283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download an FPGA configuration from memory.  <a href="#a464b5f9ea9daaf58d6d8a6212d515283">More...</a><br /></td></tr>
<tr class="separator:a464b5f9ea9daaf58d6d8a6212d515283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6f32441c518c6f9147e4ca27fdf9f3"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a6a6f32441c518c6f9147e4ca27fdf9f3">ConfigureFPGAFromMemoryWithReset</a> (const unsigned char *data, unsigned long length, const <a class="el" href="structokTFPGAResetProfile.html">okTFPGAResetProfile</a> *reset, void(*callback)(int, int, void *)=NULL, void *arg=NULL)</td></tr>
<tr class="memdesc:a6a6f32441c518c6f9147e4ca27fdf9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download an FPGA configuration from memory.  <a href="#a6a6f32441c518c6f9147e4ca27fdf9f3">More...</a><br /></td></tr>
<tr class="separator:a6a6f32441c518c6f9147e4ca27fdf9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af508321b71c6bc26786654d93347ba8e"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#af508321b71c6bc26786654d93347ba8e">ConfigureFPGAFromFlash</a> (const unsigned long configIndex, void(*callback)(int, int, void *), void *arg)</td></tr>
<tr class="memdesc:af508321b71c6bc26786654d93347ba8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download an FPGA configuration from on-board flash.  <a href="#af508321b71c6bc26786654d93347ba8e">More...</a><br /></td></tr>
<tr class="separator:af508321b71c6bc26786654d93347ba8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cc28114a2e2752fd0b830f91db377d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#ae3cc28114a2e2752fd0b830f91db377d">EnableAsynchronousTransfers</a> (bool enable)</td></tr>
<tr class="memdesc:ae3cc28114a2e2752fd0b830f91db377d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables (or disables) asynchronous bulk transfer queueing.  <a href="#ae3cc28114a2e2752fd0b830f91db377d">More...</a><br /></td></tr>
<tr class="separator:ae3cc28114a2e2752fd0b830f91db377d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7dff4a98b875d5db5091d13bdf180ac"><td class="memItemLeft" align="right" valign="top">BoardModel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#aa7dff4a98b875d5db5091d13bdf180ac">GetBoardModel</a> ()</td></tr>
<tr class="memdesc:aa7dff4a98b875d5db5091d13bdf180ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the open board model enumerated type.  <a href="#aa7dff4a98b875d5db5091d13bdf180ac">More...</a><br /></td></tr>
<tr class="separator:aa7dff4a98b875d5db5091d13bdf180ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5681ceff00c78a5443406e32eac6520f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a5681ceff00c78a5443406e32eac6520f">GetDeviceCount</a> ()</td></tr>
<tr class="memdesc:a5681ceff00c78a5443406e32eac6520f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of attached Opal Kelly devices.  <a href="#a5681ceff00c78a5443406e32eac6520f">More...</a><br /></td></tr>
<tr class="separator:a5681ceff00c78a5443406e32eac6520f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f74ef9d5511ba7d6bbd489f5392187"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#aa5f74ef9d5511ba7d6bbd489f5392187">GetDeviceID</a> ()</td></tr>
<tr class="memdesc:aa5f74ef9d5511ba7d6bbd489f5392187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the device ID string stored in EEPROM.  <a href="#aa5f74ef9d5511ba7d6bbd489f5392187">More...</a><br /></td></tr>
<tr class="separator:aa5f74ef9d5511ba7d6bbd489f5392187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4650e9d343d3b80dd89ce658adaf8ab4"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a4650e9d343d3b80dd89ce658adaf8ab4">GetDeviceInfo</a> (<a class="el" href="structokTDeviceInfo.html">okTDeviceInfo</a> *info)</td></tr>
<tr class="memdesc:a4650e9d343d3b80dd89ce658adaf8ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a device information structure.  <a href="#a4650e9d343d3b80dd89ce658adaf8ab4">More...</a><br /></td></tr>
<tr class="separator:a4650e9d343d3b80dd89ce658adaf8ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bbce82343535cb215d2d3bf460e7cd"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a69bbce82343535cb215d2d3bf460e7cd">GetFPGAResetProfile</a> (okEFPGAConfigurationMethod method, <a class="el" href="structokTFPGAResetProfile.html">okTFPGAResetProfile</a> *profile)</td></tr>
<tr class="memdesc:a69bbce82343535cb215d2d3bf460e7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current FPGA configuration reset profile for the given method.  <a href="#a69bbce82343535cb215d2d3bf460e7cd">More...</a><br /></td></tr>
<tr class="separator:a69bbce82343535cb215d2d3bf460e7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae55e05110944ceb745a145bc880f2c7"><td class="memItemLeft" align="right" valign="top">BoardModel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#aae55e05110944ceb745a145bc880f2c7">GetDeviceListModel</a> (int num)</td></tr>
<tr class="memdesc:aae55e05110944ceb745a145bc880f2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the board model of a device in the devices list.  <a href="#aae55e05110944ceb745a145bc880f2c7">More...</a><br /></td></tr>
<tr class="separator:aae55e05110944ceb745a145bc880f2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0c683a359b80d9a80d0c0ec9f8156d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a1f0c683a359b80d9a80d0c0ec9f8156d">GetDeviceListSerial</a> (int num)</td></tr>
<tr class="memdesc:a1f0c683a359b80d9a80d0c0ec9f8156d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the serial number of a device in the devices list.  <a href="#a1f0c683a359b80d9a80d0c0ec9f8156d">More...</a><br /></td></tr>
<tr class="separator:a1f0c683a359b80d9a80d0c0ec9f8156d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47245b7de2f7efa8a96eeb97cec52ac7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a47245b7de2f7efa8a96eeb97cec52ac7">GetDeviceMajorVersion</a> ()</td></tr>
<tr class="memdesc:a47245b7de2f7efa8a96eeb97cec52ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the device firmware major version.  <a href="#a47245b7de2f7efa8a96eeb97cec52ac7">More...</a><br /></td></tr>
<tr class="separator:a47245b7de2f7efa8a96eeb97cec52ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac967a1245deea121bc6b9b741847e69e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#ac967a1245deea121bc6b9b741847e69e">GetDeviceMinorVersion</a> ()</td></tr>
<tr class="memdesc:ac967a1245deea121bc6b9b741847e69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the device firmware minor version.  <a href="#ac967a1245deea121bc6b9b741847e69e">More...</a><br /></td></tr>
<tr class="separator:ac967a1245deea121bc6b9b741847e69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d14d05c226f97e06a3a458ac87b4ae3"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a0d14d05c226f97e06a3a458ac87b4ae3">GetDeviceSensors</a> (<a class="el" href="classokCDeviceSensors.html">okCDeviceSensors</a> &amp;sensors) const </td></tr>
<tr class="memdesc:a0d14d05c226f97e06a3a458ac87b4ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the array with the available sensors.  <a href="#a0d14d05c226f97e06a3a458ac87b4ae3">More...</a><br /></td></tr>
<tr class="separator:a0d14d05c226f97e06a3a458ac87b4ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca33a2019f4904e0fba55cc45fafb1a"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a0ca33a2019f4904e0fba55cc45fafb1a">GetDeviceSettings</a> (<a class="el" href="classokCDeviceSettings.html">okCDeviceSettings</a> &amp;settings)</td></tr>
<tr class="memdesc:a0ca33a2019f4904e0fba55cc45fafb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the object allowing to access the device settings.  <a href="#a0ca33a2019f4904e0fba55cc45fafb1a">More...</a><br /></td></tr>
<tr class="separator:a0ca33a2019f4904e0fba55cc45fafb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9da76fb2f276145b575b23d573db92"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a5f9da76fb2f276145b575b23d573db92">GetEepromPLL22150Configuration</a> (<a class="el" href="classokCPLL22150.html">okCPLL22150</a> &amp;pll)</td></tr>
<tr class="memdesc:a5f9da76fb2f276145b575b23d573db92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read PLL configuration from the on-board EEPROM (PLL22150).  <a href="#a5f9da76fb2f276145b575b23d573db92">More...</a><br /></td></tr>
<tr class="separator:a5f9da76fb2f276145b575b23d573db92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a650425713e28b66ddf83ef2c0863be"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a7a650425713e28b66ddf83ef2c0863be">GetEepromPLL22393Configuration</a> (<a class="el" href="classokCPLL22393.html">okCPLL22393</a> &amp;pll)</td></tr>
<tr class="memdesc:a7a650425713e28b66ddf83ef2c0863be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read PLL configuration from the on-board EEPROM (PLL22393).  <a href="#a7a650425713e28b66ddf83ef2c0863be">More...</a><br /></td></tr>
<tr class="separator:a7a650425713e28b66ddf83ef2c0863be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6673451bec6cefb859bd0928c05c09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a5d6673451bec6cefb859bd0928c05c09">GetHostInterfaceWidth</a> ()</td></tr>
<tr class="memdesc:a5d6673451bec6cefb859bd0928c05c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width of the host interface, in bits.  <a href="#a5d6673451bec6cefb859bd0928c05c09">More...</a><br /></td></tr>
<tr class="separator:a5d6673451bec6cefb859bd0928c05c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a4983d322c98ea4530b2458a02b27f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5a4983d322c98ea4530b2458a02b27f"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#aa5a4983d322c98ea4530b2458a02b27f">GetLastTransferLength</a> ()</td></tr>
<tr class="memdesc:aa5a4983d322c98ea4530b2458a02b27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the last transfer (successful or not). <br /></td></tr>
<tr class="separator:aa5a4983d322c98ea4530b2458a02b27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4ad78c98fb590695e54f8b68187df0"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a4b4ad78c98fb590695e54f8b68187df0">GetPLL22150Configuration</a> (<a class="el" href="classokCPLL22150.html">okCPLL22150</a> &amp;pll)</td></tr>
<tr class="memdesc:a4b4ad78c98fb590695e54f8b68187df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the PLL configuration via the I2C bus (PLL22150).  <a href="#a4b4ad78c98fb590695e54f8b68187df0">More...</a><br /></td></tr>
<tr class="separator:a4b4ad78c98fb590695e54f8b68187df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04fc1588d583e5fbc2794a83a3a29041"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a04fc1588d583e5fbc2794a83a3a29041">GetPLL22393Configuration</a> (<a class="el" href="classokCPLL22393.html">okCPLL22393</a> &amp;pll)</td></tr>
<tr class="memdesc:a04fc1588d583e5fbc2794a83a3a29041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the PLL configuration via the I2C bus (PLL22393).  <a href="#a04fc1588d583e5fbc2794a83a3a29041">More...</a><br /></td></tr>
<tr class="separator:a04fc1588d583e5fbc2794a83a3a29041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74063ad7ac8778530fd3f80b8ca7147"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#ae74063ad7ac8778530fd3f80b8ca7147">GetSerialNumber</a> ()</td></tr>
<tr class="memdesc:ae74063ad7ac8778530fd3f80b8ca7147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the iSerialNumber of the device.  <a href="#ae74063ad7ac8778530fd3f80b8ca7147">More...</a><br /></td></tr>
<tr class="separator:ae74063ad7ac8778530fd3f80b8ca7147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace377ac73c390322fd0832b774654920"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#ace377ac73c390322fd0832b774654920">GetWireInValue</a> (int epAddr, UINT32 *val)</td></tr>
<tr class="memdesc:ace377ac73c390322fd0832b774654920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of a particular Wire In from the internal wire data structure.  <a href="#ace377ac73c390322fd0832b774654920">More...</a><br /></td></tr>
<tr class="separator:ace377ac73c390322fd0832b774654920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179f9ffba19235bdd314dd9b2efd3054"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a179f9ffba19235bdd314dd9b2efd3054">GetWireOutValue</a> (int epAddr)</td></tr>
<tr class="memdesc:a179f9ffba19235bdd314dd9b2efd3054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of a particular Wire Out from the internal wire data structure.  <a href="#a179f9ffba19235bdd314dd9b2efd3054">More...</a><br /></td></tr>
<tr class="separator:a179f9ffba19235bdd314dd9b2efd3054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcb4c45efe892223dbea741fed4bf46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a6bcb4c45efe892223dbea741fed4bf46">IsHighSpeed</a> ()</td></tr>
<tr class="memdesc:a6bcb4c45efe892223dbea741fed4bf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is High-Speed.  <a href="#a6bcb4c45efe892223dbea741fed4bf46">More...</a><br /></td></tr>
<tr class="separator:a6bcb4c45efe892223dbea741fed4bf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfbe376b067628c91dee2484ef0e7c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#addfbe376b067628c91dee2484ef0e7c4">IsFrontPanel3Supported</a> ()</td></tr>
<tr class="memdesc:addfbe376b067628c91dee2484ef0e7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if FrontPanel-3 is firmware-supported.  <a href="#addfbe376b067628c91dee2484ef0e7c4">More...</a><br /></td></tr>
<tr class="separator:addfbe376b067628c91dee2484ef0e7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77faa8e8520e82e847a85a5d320b94b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a77faa8e8520e82e847a85a5d320b94b5">IsFrontPanelEnabled</a> ()</td></tr>
<tr class="memdesc:a77faa8e8520e82e847a85a5d320b94b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a byte from the host interface to see if FrontPanel support is built in.  <a href="#a77faa8e8520e82e847a85a5d320b94b5">More...</a><br /></td></tr>
<tr class="separator:a77faa8e8520e82e847a85a5d320b94b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edd9efc80ca11772e71dbfe130d82ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a9edd9efc80ca11772e71dbfe130d82ea">IsOpen</a> () const </td></tr>
<tr class="memdesc:a9edd9efc80ca11772e71dbfe130d82ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a device is currently open.  <a href="#a9edd9efc80ca11772e71dbfe130d82ea">More...</a><br /></td></tr>
<tr class="separator:a9edd9efc80ca11772e71dbfe130d82ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa055c82bf61bae12f877dadf0907717"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#aaa055c82bf61bae12f877dadf0907717">IsRemote</a> () const </td></tr>
<tr class="memdesc:aaa055c82bf61bae12f877dadf0907717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is connected to a remote server.  <a href="#aaa055c82bf61bae12f877dadf0907717">More...</a><br /></td></tr>
<tr class="separator:aaa055c82bf61bae12f877dadf0907717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee61a8fb308b6a76c859d19dfd009c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#aaee61a8fb308b6a76c859d19dfd009c8">IsTriggered</a> (int epAddr, UINT32 mask)</td></tr>
<tr class="memdesc:aaee61a8fb308b6a76c859d19dfd009c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the trigger has been triggered.  <a href="#aaee61a8fb308b6a76c859d19dfd009c8">More...</a><br /></td></tr>
<tr class="separator:aaee61a8fb308b6a76c859d19dfd009c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bf668d10b2e45056e3bd212e7c37a1"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a82bf668d10b2e45056e3bd212e7c37a1">GetTriggerOutVector</a> (int epAddr) const </td></tr>
<tr class="memdesc:a82bf668d10b2e45056e3bd212e7c37a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the given trigger.  <a href="#a82bf668d10b2e45056e3bd212e7c37a1">More...</a><br /></td></tr>
<tr class="separator:a82bf668d10b2e45056e3bd212e7c37a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206a26859fd2db3646dc748c815beeac"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a206a26859fd2db3646dc748c815beeac">LoadDefaultPLLConfiguration</a> ()</td></tr>
<tr class="memdesc:a206a26859fd2db3646dc748c815beeac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the PLL from settings stored in EEPROM.  <a href="#a206a26859fd2db3646dc748c815beeac">More...</a><br /></td></tr>
<tr class="separator:a206a26859fd2db3646dc748c815beeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df2e32a316faa146a0047213bb77e6c"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a8df2e32a316faa146a0047213bb77e6c">OpenBySerial</a> (std::string str=&quot;&quot;)</td></tr>
<tr class="memdesc:a8df2e32a316faa146a0047213bb77e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the specified device by serial number.  <a href="#a8df2e32a316faa146a0047213bb77e6c">More...</a><br /></td></tr>
<tr class="separator:a8df2e32a316faa146a0047213bb77e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b624f3bd41f874867f2becfdf776018"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a3b624f3bd41f874867f2becfdf776018">ReadI2C</a> (const int addr, int length, unsigned char *data)</td></tr>
<tr class="memdesc:a3b624f3bd41f874867f2becfdf776018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads I2C data from an arbitrary I2C device.  <a href="#a3b624f3bd41f874867f2becfdf776018">More...</a><br /></td></tr>
<tr class="separator:a3b624f3bd41f874867f2becfdf776018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4accb11a5bfa48798e263aa2c4d9e977"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a4accb11a5bfa48798e263aa2c4d9e977">ReadFromBlockPipeOut</a> (int epAddr, int blockSize, long length, unsigned char *data)</td></tr>
<tr class="memdesc:a4accb11a5bfa48798e263aa2c4d9e977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from a BlockPipeOut endpoint.  <a href="#a4accb11a5bfa48798e263aa2c4d9e977">More...</a><br /></td></tr>
<tr class="separator:a4accb11a5bfa48798e263aa2c4d9e977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d9da7ddea0a75c9ce408a64b14e51a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a78d9da7ddea0a75c9ce408a64b14e51a">ReadFromPipeOut</a> (int epAddr, long length, unsigned char *data)</td></tr>
<tr class="memdesc:a78d9da7ddea0a75c9ce408a64b14e51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a block from a Pipe Out endpoint.  <a href="#a78d9da7ddea0a75c9ce408a64b14e51a">More...</a><br /></td></tr>
<tr class="separator:a78d9da7ddea0a75c9ce408a64b14e51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230a2848017f7e86abe56a3144d3db0c"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a230a2848017f7e86abe56a3144d3db0c">ReadRegister</a> (UINT32 addr, UINT32 *data)</td></tr>
<tr class="memdesc:a230a2848017f7e86abe56a3144d3db0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single register.  <a href="#a230a2848017f7e86abe56a3144d3db0c">More...</a><br /></td></tr>
<tr class="separator:a230a2848017f7e86abe56a3144d3db0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5969507a9b4333844d7a9c65ba871188"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a5969507a9b4333844d7a9c65ba871188">ReadRegisters</a> (okTRegisterEntries &amp;regs)</td></tr>
<tr class="memdesc:a5969507a9b4333844d7a9c65ba871188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a set of registers.  <a href="#a5969507a9b4333844d7a9c65ba871188">More...</a><br /></td></tr>
<tr class="separator:a5969507a9b4333844d7a9c65ba871188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5494fe1f285b92b53317c1846e496f0"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#ad5494fe1f285b92b53317c1846e496f0">ResetFPGA</a> ()</td></tr>
<tr class="memdesc:ad5494fe1f285b92b53317c1846e496f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send RESET signal to FPGA design (via okHostInterface).  <a href="#ad5494fe1f285b92b53317c1846e496f0">More...</a><br /></td></tr>
<tr class="separator:ad5494fe1f285b92b53317c1846e496f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5441f0e58ebcee9b14d6a6e935207f1"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#ab5441f0e58ebcee9b14d6a6e935207f1">SetBTPipePollingInterval</a> (int interval)</td></tr>
<tr class="memdesc:ab5441f0e58ebcee9b14d6a6e935207f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the BTPipe polling interval for completion.  <a href="#ab5441f0e58ebcee9b14d6a6e935207f1">More...</a><br /></td></tr>
<tr class="separator:ab5441f0e58ebcee9b14d6a6e935207f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af458e6d190a371b1bf4f79e4e941a0d2"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#af458e6d190a371b1bf4f79e4e941a0d2">SetFPGAResetProfile</a> (okEFPGAConfigurationMethod method, const <a class="el" href="structokTFPGAResetProfile.html">okTFPGAResetProfile</a> *profile)</td></tr>
<tr class="memdesc:af458e6d190a371b1bf4f79e4e941a0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current FPGA configuration reset profile for the given method.  <a href="#af458e6d190a371b1bf4f79e4e941a0d2">More...</a><br /></td></tr>
<tr class="separator:af458e6d190a371b1bf4f79e4e941a0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5982edf22087334218e5f7f855be61e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#af5982edf22087334218e5f7f855be61e">SetDeviceID</a> (const std::string str)</td></tr>
<tr class="memdesc:af5982edf22087334218e5f7f855be61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the device ID in EEPROM.  <a href="#af5982edf22087334218e5f7f855be61e">More...</a><br /></td></tr>
<tr class="separator:af5982edf22087334218e5f7f855be61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608f7220041afb1d2b4d7450b23063fa"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a608f7220041afb1d2b4d7450b23063fa">SetPLL22150Configuration</a> (<a class="el" href="classokCPLL22150.html">okCPLL22150</a> &amp;pll)</td></tr>
<tr class="memdesc:a608f7220041afb1d2b4d7450b23063fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the PLL configuration via the I2C bus (PLL22150).  <a href="#a608f7220041afb1d2b4d7450b23063fa">More...</a><br /></td></tr>
<tr class="separator:a608f7220041afb1d2b4d7450b23063fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a81c6463d9e9de21ec5732a07750d6a"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a6a81c6463d9e9de21ec5732a07750d6a">SetPLL22393Configuration</a> (<a class="el" href="classokCPLL22393.html">okCPLL22393</a> &amp;pll)</td></tr>
<tr class="memdesc:a6a81c6463d9e9de21ec5732a07750d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the PLL configuration via the I2C bus (PLL22393).  <a href="#a6a81c6463d9e9de21ec5732a07750d6a">More...</a><br /></td></tr>
<tr class="separator:a6a81c6463d9e9de21ec5732a07750d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab978515fcf82dd1ca0953b15fbf75cb"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#aab978515fcf82dd1ca0953b15fbf75cb">SetEepromPLL22150Configuration</a> (<a class="el" href="classokCPLL22150.html">okCPLL22150</a> &amp;pll)</td></tr>
<tr class="memdesc:aab978515fcf82dd1ca0953b15fbf75cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store PLL configuration on the on-board EEPROM (PLL22150).  <a href="#aab978515fcf82dd1ca0953b15fbf75cb">More...</a><br /></td></tr>
<tr class="separator:aab978515fcf82dd1ca0953b15fbf75cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad440632ca0eb4cfd6094e1fea1c19b63"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#ad440632ca0eb4cfd6094e1fea1c19b63">SetEepromPLL22393Configuration</a> (<a class="el" href="classokCPLL22393.html">okCPLL22393</a> &amp;pll)</td></tr>
<tr class="memdesc:ad440632ca0eb4cfd6094e1fea1c19b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store PLL configuration on the on-board EEPROM (PLL22393).  <a href="#ad440632ca0eb4cfd6094e1fea1c19b63">More...</a><br /></td></tr>
<tr class="separator:ad440632ca0eb4cfd6094e1fea1c19b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb9f63c7cfe315781f52d289ca6c2bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a8bb9f63c7cfe315781f52d289ca6c2bf">SetTimeout</a> (int timeout)</td></tr>
<tr class="memdesc:a8bb9f63c7cfe315781f52d289ca6c2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the USB timeout duration (in milliseconds).  <a href="#a8bb9f63c7cfe315781f52d289ca6c2bf">More...</a><br /></td></tr>
<tr class="separator:a8bb9f63c7cfe315781f52d289ca6c2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f8b4b37ccc57dd72b5b739bbc45766"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a74f8b4b37ccc57dd72b5b739bbc45766">SetWireInValue</a> (int ep, UINT32 val, UINT32 mask=0xffffffff)</td></tr>
<tr class="memdesc:a74f8b4b37ccc57dd72b5b739bbc45766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a wire value in the internal wire data structure.  <a href="#a74f8b4b37ccc57dd72b5b739bbc45766">More...</a><br /></td></tr>
<tr class="separator:a74f8b4b37ccc57dd72b5b739bbc45766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7a732026288b052c86ad656c5fc955"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a0f7a732026288b052c86ad656c5fc955">UpdateTriggerOuts</a> ()</td></tr>
<tr class="memdesc:a0f7a732026288b052c86ad656c5fc955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads Trigger Out endpoints.  <a href="#a0f7a732026288b052c86ad656c5fc955">More...</a><br /></td></tr>
<tr class="separator:a0f7a732026288b052c86ad656c5fc955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a5ae9f0bcd08b5ebc7f75612c256f5"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a50a5ae9f0bcd08b5ebc7f75612c256f5">UpdateWireIns</a> ()</td></tr>
<tr class="memdesc:a50a5ae9f0bcd08b5ebc7f75612c256f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers current Wire In values to the FPGA.  <a href="#a50a5ae9f0bcd08b5ebc7f75612c256f5">More...</a><br /></td></tr>
<tr class="separator:a50a5ae9f0bcd08b5ebc7f75612c256f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4f41ee15d213d76dddc8b589b527b0"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#afb4f41ee15d213d76dddc8b589b527b0">UpdateWireOuts</a> ()</td></tr>
<tr class="memdesc:afb4f41ee15d213d76dddc8b589b527b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers current Wire Out values from the FPGA.  <a href="#afb4f41ee15d213d76dddc8b589b527b0">More...</a><br /></td></tr>
<tr class="separator:afb4f41ee15d213d76dddc8b589b527b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccdbdaf2cf6ba837a4c503ff9cce177"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#abccdbdaf2cf6ba837a4c503ff9cce177">FlashEraseSector</a> (UINT32 address)</td></tr>
<tr class="memdesc:abccdbdaf2cf6ba837a4c503ff9cce177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the sector at the specified address of System Flash memory.  <a href="#abccdbdaf2cf6ba837a4c503ff9cce177">More...</a><br /></td></tr>
<tr class="separator:abccdbdaf2cf6ba837a4c503ff9cce177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17fe4fffbfaa4891dd16dc9b672ed7e"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#ae17fe4fffbfaa4891dd16dc9b672ed7e">FlashWrite</a> (UINT32 address, UINT32 length, const UINT8 *buf)</td></tr>
<tr class="memdesc:ae17fe4fffbfaa4891dd16dc9b672ed7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to System Flash starting at the specified address.  <a href="#ae17fe4fffbfaa4891dd16dc9b672ed7e">More...</a><br /></td></tr>
<tr class="separator:ae17fe4fffbfaa4891dd16dc9b672ed7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d0486ed605536d99487c98556cf36a"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a43d0486ed605536d99487c98556cf36a">FlashRead</a> (UINT32 address, UINT32 length, UINT8 *buf)</td></tr>
<tr class="memdesc:a43d0486ed605536d99487c98556cf36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from System Flash starting at the specified address.  <a href="#a43d0486ed605536d99487c98556cf36a">More...</a><br /></td></tr>
<tr class="separator:a43d0486ed605536d99487c98556cf36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b8caa652f5ace0343c6784de8478db"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a20b8caa652f5ace0343c6784de8478db">WriteI2C</a> (const int addr, int length, const unsigned char *data)</td></tr>
<tr class="memdesc:a20b8caa652f5ace0343c6784de8478db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends I2C data to an arbitrary I2C device.  <a href="#a20b8caa652f5ace0343c6784de8478db">More...</a><br /></td></tr>
<tr class="separator:a20b8caa652f5ace0343c6784de8478db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4c4215b9515401faae6eb2afa5bdee"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a7f4c4215b9515401faae6eb2afa5bdee">WriteRegister</a> (UINT32 addr, UINT32 data)</td></tr>
<tr class="memdesc:a7f4c4215b9515401faae6eb2afa5bdee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a single register.  <a href="#a7f4c4215b9515401faae6eb2afa5bdee">More...</a><br /></td></tr>
<tr class="separator:a7f4c4215b9515401faae6eb2afa5bdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb3118557415653bce3bfdc435ccdf3"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#aadb3118557415653bce3bfdc435ccdf3">WriteRegisters</a> (const okTRegisterEntries &amp;regs)</td></tr>
<tr class="memdesc:aadb3118557415653bce3bfdc435ccdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a set of registers.  <a href="#aadb3118557415653bce3bfdc435ccdf3">More...</a><br /></td></tr>
<tr class="separator:aadb3118557415653bce3bfdc435ccdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1046c9a36a5442329ae20e278e2a92f5"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a1046c9a36a5442329ae20e278e2a92f5">WriteToBlockPipeIn</a> (int epAddr, int blockSize, long length, const unsigned char *data)</td></tr>
<tr class="memdesc:a1046c9a36a5442329ae20e278e2a92f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to a BlockPipeIn endpoint.  <a href="#a1046c9a36a5442329ae20e278e2a92f5">More...</a><br /></td></tr>
<tr class="separator:a1046c9a36a5442329ae20e278e2a92f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a48ebe66a14414455d6b5de7f593cf"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#ab5a48ebe66a14414455d6b5de7f593cf">WriteToPipeIn</a> (int epAddr, long length, const unsigned char *data)</td></tr>
<tr class="memdesc:ab5a48ebe66a14414455d6b5de7f593cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a block to a Pipe In endpoint.  <a href="#ab5a48ebe66a14414455d6b5de7f593cf">More...</a><br /></td></tr>
<tr class="separator:ab5a48ebe66a14414455d6b5de7f593cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a12a30dd85b13ea90882d93afb29da6de"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a12a30dd85b13ea90882d93afb29da6de">GetErrorString</a> (int errorCode)</td></tr>
<tr class="separator:a12a30dd85b13ea90882d93afb29da6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4ed79e84fad3c7b4a34b5e22398439"><td class="memItemLeft" align="right" valign="top">static ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a6b4ed79e84fad3c7b4a34b5e22398439">AddCustomDevice</a> (const okTDeviceMatchInfo &amp;matchInfo, const <a class="el" href="structokTDeviceInfo.html">okTDeviceInfo</a> *devInfo=NULL)</td></tr>
<tr class="separator:a6b4ed79e84fad3c7b4a34b5e22398439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99f02073f52d7c5e5e73a39130da434"><td class="memItemLeft" align="right" valign="top">static ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#aa99f02073f52d7c5e5e73a39130da434">RemoveCustomDevice</a> (int productID)</td></tr>
<tr class="separator:aa99f02073f52d7c5e5e73a39130da434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024636cf6f182381d51e01ad8cdda971"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a024636cf6f182381d51e01ad8cdda971"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classokCFrontPanel.html#a024636cf6f182381d51e01ad8cdda971">GetBoardModelString</a> (BoardModel m)</td></tr>
<tr class="memdesc:a024636cf6f182381d51e01ad8cdda971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string describing the given board model or "Unknown" if not found. <br /></td></tr>
<tr class="separator:a024636cf6f182381d51e01ad8cdda971"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the class that encapsulates the functionality of the FPGA boards as well as the FrontPanel extensions such as wire and trigger endpoints. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5d6ecf0224545b1160ca15de62795d27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::ActivateTriggerIn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>epAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">epAddr</td><td>The address of the TriggerIn to activate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit</td><td>The specific bit of the trigger to activate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - Operation completed successfully. </dd>
<dd>
<b>InvalidEndpoint</b> - Endpoint address outside the range for a TriggerIn.</dd></dl>
<p>This method activates the specified TriggerIn on the XEM.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a0f7a732026288b052c86ad656c5fc955" title="Reads Trigger Out endpoints. ">UpdateTriggerOuts</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#aaee61a8fb308b6a76c859d19dfd009c8" title="Returns true if the trigger has been triggered. ">IsTriggered</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6b4ed79e84fad3c7b4a34b5e22398439"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::AddCustomDevice </td>
          <td>(</td>
          <td class="paramtype">const okTDeviceMatchInfo &amp;&#160;</td>
          <td class="paramname"><em>matchInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structokTDeviceInfo.html">okTDeviceInfo</a> *&#160;</td>
          <td class="paramname"><em>devInfo</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a custom device description.</p>
<p>This method can used to indicate that a custom device with the IDs specified in <em>matchInfo</em> should be recognized as a FrontPanel device. Opening the device with these identifiers will succeed after a call to this function.</p>
<p>Please use <code>OK_PRODUCT_OEM_START</code> as offset for the product ID field, all product ID values below it are reserved for internal use.</p>
<p>Notice that it can be called more than once for the devices with different IDs but it is not needed to ever call it again for the same device. Typically, you would call it on the program startup before creating any <a class="el" href="classokCFrontPanel.html" title="This class encapsulates the functionality of an Opal Kelly FrontPanel-enabled device including FPGA c...">okCFrontPanel</a> objects.</p>
<p>The <em>devInfo</em> parameter is optional. If specified, some of its fields will override the values that would normally be returned from <a class="el" href="classokCFrontPanel.html#a4650e9d343d3b80dd89ce658adaf8ab4" title="Fills a device information structure. ">GetDeviceInfo()</a>. </p>

</div>
</div>
<a class="anchor" id="aee80bc2c65ef4e3d62f230892ad4c9b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void okCFrontPanel::Close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method can be used to close the device to release the corresponding device at the system level, e.g. to allow another process to use it, without destroying this object itself but keeping it to be reopened later. </p>

</div>
</div>
<a class="anchor" id="a8ba687692ea69eb5d033136b91586d14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::ConfigureFPGA </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>strFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int, int, void *)&#160;</td>
          <td class="paramname"><em>callback</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strFilename</td><td>A string containing the filename of the configuration file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>An optional progress callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>An optional argument to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - Configuration completed successfully. </dd>
<dd>
<b>DeviceNotOpen</b> - Communication with a device is not established. </dd>
<dd>
<b>FileError</b> - File error occurred during open or read. </dd>
<dd>
<b>InvalidBitstream</b> - The bitstream is not properly formatted. </dd>
<dd>
<b>DoneNotHigh</b> - FPGA DONE signal did not assert after configuration. </dd>
<dd>
<b>TransferError</b> - USB error has occurred during download. </dd>
<dd>
<b>CommunicationError</b> - Communication error with the firmware. </dd>
<dd>
<b>UnsupportedFeature</b> - Configuration call not supported on this device or in this configuration.</dd></dl>
<p>This method downloads a configuration file to the FPGA. The filename should be that of a valid Xilinx bitfile (generated from <b>bitgen</b>). The callback is optional and used to track progress. The prototype for a valid callback would look like:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> downloadCallback(<span class="keywordtype">int</span> length, <span class="keywordtype">int</span> count, <span class="keywordtype">void</span> *arg);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a464b5f9ea9daaf58d6d8a6212d515283" title="Download an FPGA configuration from memory. ">ConfigureFPGAFromMemory</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a6a6f32441c518c6f9147e4ca27fdf9f3" title="Download an FPGA configuration from memory. ">ConfigureFPGAFromMemoryWithReset</a> (USB 3.0 only) </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#aeaa6482e470a0e61afacc5bcc9169a0f" title="Download an FPGA configuration from a file and reset. ">ConfigureFPGAWithReset</a> (USB 3.0 only) </dd></dl>

<p>References <a class="el" href="classokCFrontPanel.html#a464b5f9ea9daaf58d6d8a6212d515283">ConfigureFPGAFromMemory()</a>.</p>

</div>
</div>
<a class="anchor" id="af508321b71c6bc26786654d93347ba8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::ConfigureFPGAFromFlash </td>
          <td>(</td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>configIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int, int, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">configIndex</td><td>Storage index to the FPGA configuration to load. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>An optional progress callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>An optional argument to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>ErrorCode</b> - See <a class="el" href="classokCFrontPanel.html#a8ba687692ea69eb5d033136b91586d14" title="Download an FPGA configuration from a file. ">ConfigureFPGA</a> for details.</dd></dl>
<p>This method downloads a configuration file to the FPGA that has been and stored in on-board Flash memory.</p>
<p><b>Device Support:</b> This method is only available for USB 3.0 devices.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a8ba687692ea69eb5d033136b91586d14" title="Download an FPGA configuration from a file. ">ConfigureFPGA</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a464b5f9ea9daaf58d6d8a6212d515283" title="Download an FPGA configuration from memory. ">ConfigureFPGAFromMemory</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a6a6f32441c518c6f9147e4ca27fdf9f3" title="Download an FPGA configuration from memory. ">ConfigureFPGAFromMemoryWithReset</a> (USB 3.0 only) </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#aeaa6482e470a0e61afacc5bcc9169a0f" title="Download an FPGA configuration from a file and reset. ">ConfigureFPGAWithReset</a> (USB 3.0 only) </dd></dl>

</div>
</div>
<a class="anchor" id="a464b5f9ea9daaf58d6d8a6212d515283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::ConfigureFPGAFromMemory </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int, int, void *)&#160;</td>
          <td class="paramname"><em>callback</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a memory buffer containing the configuration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the configuration memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>An optional progress callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>An optional argument to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>ErrorCode</b> - See <a class="el" href="classokCFrontPanel.html#a8ba687692ea69eb5d033136b91586d14" title="Download an FPGA configuration from a file. ">ConfigureFPGA</a> for details.</dd></dl>
<p>This method downloads a configuration file to the FPGA that has been read and stored in memory. The data buffer must contain a loaded Xilinx bitfile (generated from <b>bitgen</b>).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a8ba687692ea69eb5d033136b91586d14" title="Download an FPGA configuration from a file. ">ConfigureFPGA</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a6a6f32441c518c6f9147e4ca27fdf9f3" title="Download an FPGA configuration from memory. ">ConfigureFPGAFromMemoryWithReset</a> (USB 3.0 only) </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#aeaa6482e470a0e61afacc5bcc9169a0f" title="Download an FPGA configuration from a file and reset. ">ConfigureFPGAWithReset</a> (USB 3.0 only) </dd></dl>

<p>Referenced by <a class="el" href="classokCFrontPanel.html#a8ba687692ea69eb5d033136b91586d14">ConfigureFPGA()</a>.</p>

</div>
</div>
<a class="anchor" id="a6a6f32441c518c6f9147e4ca27fdf9f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::ConfigureFPGAFromMemoryWithReset </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structokTFPGAResetProfile.html">okTFPGAResetProfile</a> *&#160;</td>
          <td class="paramname"><em>reset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int, int, void *)&#160;</td>
          <td class="paramname"><em>callback</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a memory buffer containing the configuration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the configuration memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reset</td><td>Pointer to an FPGA Reset Profile to perform after configuration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>An optional progress callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>An optional argument to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>ErrorCode</b> - See <a class="el" href="classokCFrontPanel.html#a8ba687692ea69eb5d033136b91586d14" title="Download an FPGA configuration from a file. ">ConfigureFPGA</a> for details.</dd></dl>
<p>This method downloads a configuration file to the FPGA that has been read and stored in memory. The data buffer must contain a loaded Xilinx bitfile (generated from <b>bitgen</b>). After successful configuration, the FPGA is reset according to the provided reset profile.</p>
<p><b>Device Support:</b> This method is only available for USB 3.0 devices.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a8ba687692ea69eb5d033136b91586d14" title="Download an FPGA configuration from a file. ">ConfigureFPGA</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a464b5f9ea9daaf58d6d8a6212d515283" title="Download an FPGA configuration from memory. ">ConfigureFPGAFromMemory</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#aeaa6482e470a0e61afacc5bcc9169a0f" title="Download an FPGA configuration from a file and reset. ">ConfigureFPGAWithReset</a> (USB 3.0 only) </dd></dl>

</div>
</div>
<a class="anchor" id="aeaa6482e470a0e61afacc5bcc9169a0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::ConfigureFPGAWithReset </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>strFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structokTFPGAResetProfile.html">okTFPGAResetProfile</a> *&#160;</td>
          <td class="paramname"><em>reset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int, int, void *)&#160;</td>
          <td class="paramname"><em>callback</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strFilename</td><td>A string containing the filename of the configuration file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>An optional progress callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reset</td><td>FPGA Reset profile to perform after configuration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>An optional argument to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - Configuration completed successfully. </dd>
<dd>
<b>DeviceNotOpen</b> - Communication with a device is not established. </dd>
<dd>
<b>FileError</b> - File error occurred during open or read. </dd>
<dd>
<b>InvalidBitstream</b> - The bitstream is not properly formatted. </dd>
<dd>
<b>DoneNotHigh</b> - FPGA DONE signal did not assert after configuration. </dd>
<dd>
<b>TransferError</b> - USB error has occurred during download. </dd>
<dd>
<b>CommunicationError</b> - Communication error with the firmware.</dd></dl>
<p>This method downloads a configuration file to the FPGA and performs the specified Reset Profile after configuration. The filename should be that of a valid Xilinx bitfile (generated from <b>bitgen</b>). The callback is optional and used to track progress. The prototype for a valid callback would look like:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> downloadCallback(<span class="keywordtype">int</span> length, <span class="keywordtype">int</span> count, <span class="keywordtype">void</span> *arg);</div></div><!-- fragment --><p>After successful configuration, the FPGA is reset according to the provided Reset Profile, an example of which is below:</p>
<div class="fragment"><div class="line"><a class="code" href="structokTFPGAResetProfile.html">okTFPGAResetProfile</a> resetProfile;</div><div class="line">resetProfile.u32DoneWaitUS             = 1000;</div><div class="line">resetProfile.u32ResetWaitUS            = 10000;</div><div class="line">resetProfile.u32RegisterWaitUS         = 10000;</div><div class="line">resetProfile.u32WireInValues[0]        = 0xFEEDA55A;</div><div class="line">resetProfile.u32WireInValues[1]        = 0x12345678;</div><div class="line">resetProfile.u32NumTriggerEntries      = 2;</div><div class="line">resetProfile.u32NumRegisterEntries     = 1;</div><div class="line">resetProfile.trigEntries[0].u32Trigger = 0x40;</div><div class="line">resetProfile.trigEntries[0].u32Mask    = 0x00000002;</div><div class="line">resetProfile.trigEntries[1].u32Trigger = 0x40;</div><div class="line">resetProfile.trigEntries[1].u32Mask    = 0x00000002;</div><div class="line">resetProfile.regEntries[0].u32Address  = 0x0;</div><div class="line">resetProfile.regEntries[0].u32Data     = 0xBEEFF00D;</div><div class="line">xem-&gt;ConfigureFPGAWithReset(<span class="stringliteral">&quot;counters.bit&quot;</span>, &amp;resetProfile);</div></div><!-- fragment --><p><b>Device Support:</b> This method is only available for USB 3.0 devices.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a8ba687692ea69eb5d033136b91586d14" title="Download an FPGA configuration from a file. ">ConfigureFPGA</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a464b5f9ea9daaf58d6d8a6212d515283" title="Download an FPGA configuration from memory. ">ConfigureFPGAFromMemory</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a6a6f32441c518c6f9147e4ca27fdf9f3" title="Download an FPGA configuration from memory. ">ConfigureFPGAFromMemoryWithReset</a> (USB 3.0 only) </dd></dl>

</div>
</div>
<a class="anchor" id="ae3cc28114a2e2752fd0b830f91db377d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void okCFrontPanel::EnableAsynchronousTransfers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>true to enable async transfers, false to disable them.</td></tr>
  </table>
  </dd>
</dl>
<p>Asynchronous queueing of bulk transfer requests is a technique used to increase the throughput of the USB stack. This technique is known to cause problems on some operating systems (notably Windows 2000 with certain USB drivers).</p>
<p>If you experience problems with configuration and/or pipe transfers, try disabling async transfers. There will be a performance penalty. </p>

</div>
</div>
<a class="anchor" id="abccdbdaf2cf6ba837a4c503ff9cce177"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::FlashEraseSector </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Address within the sector to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - The operation was successful. </dd>
<dd>
<b>Failed</b> - The operation could not be completed. </dd>
<dd>
<b>DeviceNotOpen</b> - A device is not open. </dd>
<dd>
<b>UnsupportedFeature</b> - Method not supported on this device or configuration. </dd>
<dd>
<b>InvalidParameter</b> - Address specified is invalid for erase operation. </dd>
<dd>
<b>Timeout</b> - The operation did not complete in the expected time.</dd></dl>
<p>Erases a single sector in System Flash memory. The sector to erase is determined based on the provided address. Any address within the sector will specify that the entire sector be erased. The sector specified must be in the acceptable range for the user area of Flash memory for the device. See the device User's Manual for Flash memory layout details.</p>
<p>The method blocks and returns when the operation completes. Sector erase times vary, but are approximately one second per sector.</p>
<p>Refer to the device-specific <em>User's Manual</em> for Flash layout and restrictions.</p>
<dl class="section note"><dt>Note</dt><dd>This method is only supported for USB 3.0 devices.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#ae17fe4fffbfaa4891dd16dc9b672ed7e" title="Writes data to System Flash starting at the specified address. ">FlashWrite</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a43d0486ed605536d99487c98556cf36a" title="Reads data from System Flash starting at the specified address. ">FlashRead</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a43d0486ed605536d99487c98556cf36a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::FlashRead </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8 *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Byte address to begin read operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of data to read (in bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to data buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - The operation was successful. </dd>
<dd>
<b>Failed</b> - The operation could not be completed. </dd>
<dd>
<b>DeviceNotOpen</b> - A device is not open. </dd>
<dd>
<b>UnsupportedFeature</b> - Method not supported on this device or configuration. </dd>
<dd>
<b>InvalidParameter</b> - Address or length specified is invalid. </dd>
<dd>
<b>Timeout</b> - The operation did not complete in the expected time.</dd></dl>
<p>Reads data from System Flash memory starting at the specified address. The address and length must both be integer multiples of the System Flash page size.</p>
<p>Refer to the device-specific <em>User's Manual</em> for Flash layout and restrictions.</p>
<dl class="section note"><dt>Note</dt><dd>This method is only supported for USB 3.0 devices.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#abccdbdaf2cf6ba837a4c503ff9cce177" title="Erases the sector at the specified address of System Flash memory. ">FlashEraseSector</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#ae17fe4fffbfaa4891dd16dc9b672ed7e" title="Writes data to System Flash starting at the specified address. ">FlashWrite</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae17fe4fffbfaa4891dd16dc9b672ed7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::FlashWrite </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UINT8 *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Byte address to begin write operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of data to write (in bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to data to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - The operation was successful. </dd>
<dd>
<b>Failed</b> - The operation could not be completed. </dd>
<dd>
<b>DeviceNotOpen</b> - A device is not open. </dd>
<dd>
<b>UnsupportedFeature</b> - Method not supported on this device or configuration. </dd>
<dd>
<b>InvalidParameter</b> - Address or length specified is invalid. </dd>
<dd>
<b>Timeout</b> - The operation did not complete in the expected time.</dd></dl>
<p>Writes data to System Flash memory starting at the specified address. The address and length must both be integer multiples of the System Flash page size. This method will not erase the sector prior to writing. You must use <a class="el" href="classokCFrontPanel.html#abccdbdaf2cf6ba837a4c503ff9cce177" title="Erases the sector at the specified address of System Flash memory. ">FlashEraseSector</a> to erase a sector prior to writing.</p>
<p>Refer to the device-specific <em>User's Manual</em> for Flash layout and restrictions.</p>
<dl class="section note"><dt>Note</dt><dd>This method is only supported for USB 3.0 devices.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#abccdbdaf2cf6ba837a4c503ff9cce177" title="Erases the sector at the specified address of System Flash memory. ">FlashEraseSector</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a43d0486ed605536d99487c98556cf36a" title="Reads data from System Flash starting at the specified address. ">FlashRead</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa7dff4a98b875d5db5091d13bdf180ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::BoardModel okCFrontPanel::GetBoardModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The board model of the currently-open device. If the device is unknown, <b>brdUnkown</b> is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><b> This method has been DEPRECATED and will be removed from a future version of the API. The preferred method is <a class="el" href="classokCFrontPanel.html#a4650e9d343d3b80dd89ce658adaf8ab4" title="Fills a device information structure. ">GetDeviceInfo</a>. </b></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a4650e9d343d3b80dd89ce658adaf8ab4" title="Fills a device information structure. ">GetDeviceInfo</a> </dd></dl>

<p>References <a class="el" href="structokTDeviceInfo.html#a8499afc882f767f8643e6528b2b002e8">okTDeviceInfo::productID</a>.</p>

</div>
</div>
<a class="anchor" id="a5681ceff00c78a5443406e32eac6520f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int okCFrontPanel::GetDeviceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Prefer to use <a class="el" href="classOpalKelly_1_1FrontPanelDevices.html#a11fb3c6618a0a4979830534894c98f50" title="Returns the number of available devices, possibly 0. ">OpalKelly::FrontPanelDevices::GetCount()</a> in the new code, see <a class="el" href="migrate_fpdevices.html">Switching to OpalKelly::FrontPanelDevices</a> for more information.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of devices attached.</dd></dl>
<p>Queries to determine how many Opal Kelly devices are attached. This method also builds a list of serial numbers and board models which can subsequently be queried using the methods <a class="el" href="classokCFrontPanel.html#a1f0c683a359b80d9a80d0c0ec9f8156d" title="Returns the serial number of a device in the devices list. ">GetDeviceListSerial()</a> and <a class="el" href="classokCFrontPanel.html#aae55e05110944ceb745a145bc880f2c7" title="Returns the board model of a device in the devices list. ">GetDeviceListModel()</a>, respectively. </p>

</div>
</div>
<a class="anchor" id="aa5f74ef9d5511ba7d6bbd489f5392187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string okCFrontPanel::GetDeviceID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A string containing the Device ID. If a device is not open, the string will be empty.</dd></dl>
<p>This method retrieves the current XEM Device ID string from the device.</p>
<dl class="section note"><dt>Note</dt><dd><b> This method has been DEPRECATED and will be removed from a future version of the API. The preferred method is <a class="el" href="classokCFrontPanel.html#a4650e9d343d3b80dd89ce658adaf8ab4" title="Fills a device information structure. ">GetDeviceInfo</a>. </b></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a4650e9d343d3b80dd89ce658adaf8ab4" title="Fills a device information structure. ">GetDeviceInfo</a> </dd></dl>

<p>References <a class="el" href="structokTDeviceInfo.html#a1b3f1bdaa9322a8ec311c1bbc8e5352b">okTDeviceInfo::deviceID</a>.</p>

</div>
</div>
<a class="anchor" id="a4650e9d343d3b80dd89ce658adaf8ab4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::GetDeviceInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structokTDeviceInfo.html">okTDeviceInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>Pointer to an allocated okDeviceInfo structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - Operation completed successfully. </dd>
<dd>
<b>DeviceNotOpen</b> - Device is not open. </dd>
<dd>
<b>InvalidParameter</b> - The provided <a class="el" href="structokTDeviceInfo.html" title="Describes several attributes of a connected device. ">okTDeviceInfo</a> pointer is null or points to an incorrectly sized structure. The latter can mostly happen only when the application uses a version of the shared library incompatible with the one it was compiled with.</dd></dl>
<p>Fills the <a class="el" href="structokTDeviceInfo.html" title="Describes several attributes of a connected device. ">okTDeviceInfo</a> structure with information about the device. </p>

</div>
</div>
<a class="anchor" id="aae55e05110944ceb745a145bc880f2c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::BoardModel okCFrontPanel::GetDeviceListModel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Prefer to use <a class="el" href="classOpalKelly_1_1FrontPanelDevices.html#a4c76c5201c52a52a5886c4d20ea677e4">OpalKelly::FrontPanelDevices::Open()</a> and <a class="el" href="classokCFrontPanel.html#aa7dff4a98b875d5db5091d13bdf180ac" title="Returns the open board model enumerated type. ">GetBoardModel()</a> in the new code, see <a class="el" href="migrate_fpdevices.html">Switching to OpalKelly::FrontPanelDevices</a> for more information.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Device number to query (0 to count-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The board model (enumerated type) of the specified device.</dd></dl>
<p>This method returns the board model of a particular attached device. The device count must have already been queried using a call to <a class="el" href="classokCFrontPanel.html#a5681ceff00c78a5443406e32eac6520f" title="Returns the number of attached Opal Kelly devices. ">GetDeviceCount()</a>. If a board is unknown or num is outside the range of attached devices, <b>okCUsbFrontPanel::brdUnknown</b> will be returned. </p>

</div>
</div>
<a class="anchor" id="a1f0c683a359b80d9a80d0c0ec9f8156d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string okCFrontPanel::GetDeviceListSerial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Prefer to use <a class="el" href="classOpalKelly_1_1FrontPanelDevices.html#af88b38bb85d1fbf03fedbffae3a02342">OpalKelly::FrontPanelDevices::GetSerial()</a> in the new code, see <a class="el" href="migrate_fpdevices.html">Switching to OpalKelly::FrontPanelDevices</a> for more information.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Device number to query (0 to count-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The serial number string of the specified device.</dd></dl>
<p>This method returns the serial number of a particular attached device. The device count must have already been queried using a call to <a class="el" href="classokCFrontPanel.html#a5681ceff00c78a5443406e32eac6520f" title="Returns the number of attached Opal Kelly devices. ">GetDeviceCount()</a>. If num is outside the range of attached devices, an empty string will be returned. The serial number may then be used to open the device by calling <a class="el" href="classokCFrontPanel.html#a8df2e32a316faa146a0047213bb77e6c" title="Opens the specified device by serial number. ">OpenBySerial()</a>. </p>

</div>
</div>
<a class="anchor" id="a47245b7de2f7efa8a96eeb97cec52ac7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int okCFrontPanel::GetDeviceMajorVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The firmware's major version number or -1 if the query failed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><b> This method has been DEPRECATED and will be removed from a future version of the API. The preferred method is <a class="el" href="classokCFrontPanel.html#a4650e9d343d3b80dd89ce658adaf8ab4" title="Fills a device information structure. ">GetDeviceInfo</a>. </b></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a4650e9d343d3b80dd89ce658adaf8ab4" title="Fills a device information structure. ">GetDeviceInfo</a> </dd></dl>

<p>References <a class="el" href="structokTDeviceInfo.html#a9546abf1068f50365ed4b1eaf576076e">okTDeviceInfo::deviceMajorVersion</a>.</p>

</div>
</div>
<a class="anchor" id="ac967a1245deea121bc6b9b741847e69e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int okCFrontPanel::GetDeviceMinorVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The firmware's minor version number or -1 if the query failed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><b> This method has been DEPRECATED and will be removed from a future version of the API. The preferred method is <a class="el" href="classokCFrontPanel.html#a4650e9d343d3b80dd89ce658adaf8ab4" title="Fills a device information structure. ">GetDeviceInfo</a>. </b></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a4650e9d343d3b80dd89ce658adaf8ab4" title="Fills a device information structure. ">GetDeviceInfo</a> </dd></dl>

<p>References <a class="el" href="structokTDeviceInfo.html#a883246a3638a5c1c1a2a803c80c1e984">okTDeviceInfo::deviceMinorVersion</a>.</p>

</div>
</div>
<a class="anchor" id="a0d14d05c226f97e06a3a458ac87b4ae3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::GetDeviceSensors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classokCDeviceSensors.html">okCDeviceSensors</a> &amp;&#160;</td>
          <td class="paramname"><em>sensors</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sensors</td><td>An instance of <a class="el" href="classokCDeviceSensors.html" title="Represents the set of read-only sensors available on certain devices. ">okCDeviceSensors</a> that will be modified with the sensor information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - Write has completed successfully. </dd>
<dd>
<b>Failed</b> - Retrieving sensors from the device failed. </dd>
<dd>
<b>DeviceNotOpen</b> - Communication with a XEM is not established. </dd>
<dd>
<b>UnsupportedFeature</b> - Unless the device supports Device Sensors.</dd></dl>
<p><b>Device Support:</b> This method is only available for USB 3.0 devices.</p>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> count;</div><div class="line"><a class="code" href="classokCDeviceSensors.html">okCDeviceSensors</a> sensors;</div><div class="line"><a class="code" href="structokTDeviceSensor.html">okTDeviceSensor</a>  sensor;</div><div class="line">dev.GetDeviceSensors(sensors);</div><div class="line">count = sensors.<a class="code" href="classokCDeviceSensors.html#a29e36f1fe587a73f5f720e49464980db">GetSensorCount</a>();          <span class="comment">// Returns the number of sensors.</span></div><div class="line">sensor = sensors.<a class="code" href="classokCDeviceSensors.html#a6a854d763c0f96063b43761d7d286f9f">GetSensor</a>(0);              <span class="comment">// Returns the first sensor in the list.</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0ca33a2019f4904e0fba55cc45fafb1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::GetDeviceSettings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classokCDeviceSettings.html">okCDeviceSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">settings</td><td>An instance of <a class="el" href="classokCDeviceSettings.html" title="Represents the set of settings stored in the given device. ">okCDeviceSettings</a> that will operate on device settings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - Completed successfully. </dd>
<dd>
<b>DeviceNotOpen</b> - Communication with a device is not established. </dd>
<dd>
<b>UnsupportedFeature</b> - Unless the device supports Device Settings.</dd></dl>
<p><b>Device Support:</b> This method is only available for USB 3.0 devices.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCDeviceSettings.html" title="Represents the set of settings stored in the given device. ">okCDeviceSettings</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5f9da76fb2f276145b575b23d573db92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::GetEepromPLL22150Configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classokCPLL22150.html">okCPLL22150</a> &amp;&#160;</td>
          <td class="paramname"><em>pll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pll</td><td>A reference to an <a class="el" href="classokCPLL22150.html" title="Container class which holds the appropriate configuration parameters for a Cypress 22150 PLL...">okCPLL22150</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NoError - Operation complete successfully. </dd>
<dd>
DeviceNotOpen - Device is not open.</dd></dl>
<p>This method retrieves the current PLL configuration from the on-board XEM EEPROM. The <b>pll</b> object is then initialized with this configuration.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a4b4ad78c98fb590695e54f8b68187df0" title="Read the PLL configuration via the I2C bus (PLL22150). ">GetPLL22150Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a206a26859fd2db3646dc748c815beeac" title="Configures the PLL from settings stored in EEPROM. ">LoadDefaultPLLConfiguration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a608f7220041afb1d2b4d7450b23063fa" title="Store the PLL configuration via the I2C bus (PLL22150). ">SetPLL22150Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#aab978515fcf82dd1ca0953b15fbf75cb" title="Store PLL configuration on the on-board EEPROM (PLL22150). ">SetEepromPLL22150Configuration</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7a650425713e28b66ddf83ef2c0863be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::GetEepromPLL22393Configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classokCPLL22393.html">okCPLL22393</a> &amp;&#160;</td>
          <td class="paramname"><em>pll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pll</td><td>A reference to an <a class="el" href="classokCPLL22393.html" title="Container class which holds the appropriate configuration parameters for a Cypress 22393 PLL...">okCPLL22393</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NoError - Operation complete successfully. </dd>
<dd>
DeviceNotOpen - Device is not open.</dd></dl>
<p>This method retrieves the current PLL configuration from the on-board XEM EEPROM. The <b>pll</b> object is then initialized with this configuration.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a04fc1588d583e5fbc2794a83a3a29041" title="Read the PLL configuration via the I2C bus (PLL22393). ">GetPLL22393Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a206a26859fd2db3646dc748c815beeac" title="Configures the PLL from settings stored in EEPROM. ">LoadDefaultPLLConfiguration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a6a81c6463d9e9de21ec5732a07750d6a" title="Store the PLL configuration via the I2C bus (PLL22393). ">SetPLL22393Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#ad440632ca0eb4cfd6094e1fea1c19b63" title="Store PLL configuration on the on-board EEPROM (PLL22393). ">SetEepromPLL22393Configuration</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a12a30dd85b13ea90882d93afb29da6de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string okCFrontPanel::GetErrorString </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>errorCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a user-readable string corresponding to the given error code.</p>
<p>The <em>errorCode</em> should be an element of ErrorCode enum different from NoError. </p>

</div>
</div>
<a class="anchor" id="a69bbce82343535cb215d2d3bf460e7cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::GetFPGAResetProfile </td>
          <td>(</td>
          <td class="paramtype">okEFPGAConfigurationMethod&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structokTFPGAResetProfile.html">okTFPGAResetProfile</a> *&#160;</td>
          <td class="paramname"><em>profile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Indicates which reset profile should be retrieved. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">profile</td><td>Boot FPGA Reset Profile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - Write has completed successfully. </dd>
<dd>
<b>DeviceNotOpen</b> - Communication with a device is not established. </dd>
<dd>
<b>UnsupportedFeature</b> - Method not supported for this device. </dd>
<dd>
<b>InvalidParameter</b> - Invalid configuration method or NULL profile pointer. </dd>
<dd>
<b>Failed</b> - Request failed.</dd></dl>
<p>This method queries the firmware for the current FPGA Boot or JTAG Reset Profile. The result is returned in the Reset Profile pointed to by <b>profile</b>.</p>
<p><b>Note:</b> This method is only available in the C/C++ DLL.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#af458e6d190a371b1bf4f79e4e941a0d2" title="Set the current FPGA configuration reset profile for the given method. ">SetFPGAResetProfile</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5d6673451bec6cefb859bd0928c05c09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int okCFrontPanel::GetHostInterfaceWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The width of the host interface, in bits. 0 if no device is open.</dd></dl>
<p>The host interface width is device dependent. All USB 2.0 devices have a 16-bit host interface except for the XEM3001v1 (very early release) which has an 8-bit interface. All PCI Express devices have a 32-bit host interface. All USB 3.0 devices have a 32-bit host interface.</p>
<dl class="section note"><dt>Note</dt><dd><b> This method has been DEPRECATED and will be removed from a future version of the API. The preferred method is <a class="el" href="classokCFrontPanel.html#a4650e9d343d3b80dd89ce658adaf8ab4" title="Fills a device information structure. ">GetDeviceInfo</a>. </b></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a4650e9d343d3b80dd89ce658adaf8ab4" title="Fills a device information structure. ">GetDeviceInfo</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab62c291d8dafb39ee722f603c8a1e390"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * okCFrontPanel::GetLastErrorMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the message corresponding to the last error, if any.</p>
<p>This method can be used after any of the other methods of this class returning ErrorCode returns an error code different from NoError to check if there is an associated error message further explaining the problem.</p>
<p>Note that the returned pointer only remains valid until the next call to a method of this object or its destruction, so it should be either used immediately or a copy of the string needs to be made by caller.</p>
<p>Returns <code>NULL</code> if there is no error message (which doesn't mean that the error hadn't occurred, but just that there is no additional information about it). </p>

</div>
</div>
<a class="anchor" id="a4b4ad78c98fb590695e54f8b68187df0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::GetPLL22150Configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classokCPLL22150.html">okCPLL22150</a> &amp;&#160;</td>
          <td class="paramname"><em>pll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pll</td><td>A reference to an <a class="el" href="classokCPLL22150.html" title="Container class which holds the appropriate configuration parameters for a Cypress 22150 PLL...">okCPLL22150</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NoError - Operation complete successfully. </dd>
<dd>
DeviceNotOpen - Device is not open.</dd></dl>
<p>Reads the current PLL configuration over the I2C bus and modifies the <b>pll</b> argument to reflect that configuration.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a5f9da76fb2f276145b575b23d573db92" title="Read PLL configuration from the on-board EEPROM (PLL22150). ">GetEepromPLL22150Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a206a26859fd2db3646dc748c815beeac" title="Configures the PLL from settings stored in EEPROM. ">LoadDefaultPLLConfiguration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a608f7220041afb1d2b4d7450b23063fa" title="Store the PLL configuration via the I2C bus (PLL22150). ">SetPLL22150Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#aab978515fcf82dd1ca0953b15fbf75cb" title="Store PLL configuration on the on-board EEPROM (PLL22150). ">SetEepromPLL22150Configuration</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a04fc1588d583e5fbc2794a83a3a29041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::GetPLL22393Configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classokCPLL22393.html">okCPLL22393</a> &amp;&#160;</td>
          <td class="paramname"><em>pll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pll</td><td>A reference to an <a class="el" href="classokCPLL22393.html" title="Container class which holds the appropriate configuration parameters for a Cypress 22393 PLL...">okCPLL22393</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NoError - Operation complete successfully. </dd>
<dd>
DeviceNotOpen - Device is not open.</dd></dl>
<p>Reads the current PLL configuration over the I2C bus and modifies the <b>pll</b> argument to reflect that configuration.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a7a650425713e28b66ddf83ef2c0863be" title="Read PLL configuration from the on-board EEPROM (PLL22393). ">GetEepromPLL22393Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a206a26859fd2db3646dc748c815beeac" title="Configures the PLL from settings stored in EEPROM. ">LoadDefaultPLLConfiguration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a6a81c6463d9e9de21ec5732a07750d6a" title="Store the PLL configuration via the I2C bus (PLL22393). ">SetPLL22393Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#ad440632ca0eb4cfd6094e1fea1c19b63" title="Store PLL configuration on the on-board EEPROM (PLL22393). ">SetEepromPLL22393Configuration</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae74063ad7ac8778530fd3f80b8ca7147"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string okCFrontPanel::GetSerialNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A string containing the device serial number. If no device is open, the string will be empty.</dd></dl>
<p>This method will retrieve the 10-character serial number stored in the EEPROM. This serial number is unique to each device and can therefore be used to discriminate multiple devices. Each character in the serial number is an upper or lower case character.</p>
<div class="fragment"><div class="line">std::string strSerialNumber;</div><div class="line">strSerialNumber = xem-&gt;GetSerialNumber();</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><b> This method has been DEPRECATED and will be removed from a future version of the API. The preferred method is <a class="el" href="classokCFrontPanel.html#a4650e9d343d3b80dd89ce658adaf8ab4" title="Fills a device information structure. ">GetDeviceInfo</a>. </b></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a4650e9d343d3b80dd89ce658adaf8ab4" title="Fills a device information structure. ">GetDeviceInfo</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a82bf668d10b2e45056e3bd212e7c37a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 okCFrontPanel::GetTriggerOutVector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>epAddr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">epAddr</td><td>The TriggerOut address to query.</td></tr>
  </table>
  </dd>
</dl>
<p>This method allows to retrieve the full vector of values for a particular TriggerOut endpoint. It is usually preferable to use <a class="el" href="classokCFrontPanel.html#aaee61a8fb308b6a76c859d19dfd009c8" title="Returns true if the trigger has been triggered. ">IsTriggered()</a> to test for a single trigger instead.</p>
<p>Returns 0 in case of error, e.g. an invalid trigger endpoint.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a0f7a732026288b052c86ad656c5fc955" title="Reads Trigger Out endpoints. ">UpdateTriggerOuts</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ace377ac73c390322fd0832b774654920"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::GetWireInValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>epAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32 *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">epAddr</td><td>The address of the WireIn to query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Pointer to a UINT32 to contain the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - Operation completed successfully. </dd>
<dd>
<b>InvalidEnpoint</b> - Endpoint address outside the range for WireIn. </dd>
<dd>
<b>DeviceNotOpen</b> - Device is not open. </dd>
<dd>
<b>UnsupportedFeature</b> - Supported only for USB 3.0 devices.</dd></dl>
<p><b>Note:</b> USB 3.0 device support only.</p>
<p>Gets the value of a particular WireIn from the internal wire data structure. The device firmware maintains a copy of WireIn values that are queried post-configuration and whenever a new instance of <a class="el" href="classokCFrontPanel.html" title="This class encapsulates the functionality of an Opal Kelly FrontPanel-enabled device including FPGA c...">okCFrontPanel</a> is created for a device that has an active FrontPanel-enabled configuration.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a179f9ffba19235bdd314dd9b2efd3054" title="Gets the value of a particular Wire Out from the internal wire data structure. ">GetWireOutValue</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a74f8b4b37ccc57dd72b5b739bbc45766" title="Sets a wire value in the internal wire data structure. ">SetWireInValue</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a50a5ae9f0bcd08b5ebc7f75612c256f5" title="Transfers current Wire In values to the FPGA. ">UpdateWireIns</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#afb4f41ee15d213d76dddc8b589b527b0" title="Transfers current Wire Out values from the FPGA. ">UpdateWireOuts</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a179f9ffba19235bdd314dd9b2efd3054"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 okCFrontPanel::GetWireOutValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>epAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">epAddr</td><td>The WireOut address to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the WireOut.</dd></dl>
<p>This method provides a way to get a particular WireOut value. For example,</p>
<div class="fragment"><div class="line"><span class="comment">// First, query all XEM WireOuts.</span></div><div class="line">xem-&gt;UpdateWireOuts();</div><div class="line"><span class="comment">// Now, get values from endpoints 0x21 and 0x27.</span></div><div class="line">a = xem-&gt;GetWireOutValue(0x21);</div><div class="line">b = xem-&gt;GetWireOutValue(0x27);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#ace377ac73c390322fd0832b774654920" title="Gets the value of a particular Wire In from the internal wire data structure. ">GetWireInValue</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a74f8b4b37ccc57dd72b5b739bbc45766" title="Sets a wire value in the internal wire data structure. ">SetWireInValue</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a50a5ae9f0bcd08b5ebc7f75612c256f5" title="Transfers current Wire In values to the FPGA. ">UpdateWireIns</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#afb4f41ee15d213d76dddc8b589b527b0" title="Transfers current Wire Out values from the FPGA. ">UpdateWireOuts</a> </dd></dl>

</div>
</div>
<a class="anchor" id="addfbe376b067628c91dee2484ef0e7c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool okCFrontPanel::IsFrontPanel3Supported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if FrontPanel-3 support is provided by the device firmware.</dd></dl>
<p>This method checks the firmware device version to determine if FrontPanel-3 methods are supported. These are:</p><ul>
<li><b>WriteToBlockPipeIn</b> </li>
<li><b>ReadFromBlockPipeOut</b> </li>
</ul>

</div>
</div>
<a class="anchor" id="a77faa8e8520e82e847a85a5d320b94b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool okCFrontPanel::IsFrontPanelEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if FrontPanel support is present, false otherwise.</dd></dl>
<p>This method checks to see if the FrontPanel Host Interface has been instantiated in the FPGA design. If it is detected, FrontPanel support is enabled and endpoint functionality is available. </p>

</div>
</div>
<a class="anchor" id="a6bcb4c45efe892223dbea741fed4bf46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool okCFrontPanel::IsHighSpeed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the device is operating at high-speed. false if full-speed.</dd></dl>
<p>Queries the device to determine which USB speed it has enumerated at. It will return <b>true</b> if high-speed (480Mbps), <b>false</b> otherwise (full-speed, 12Mbps).</p>
<p><b>Note:</b> This method only detects the speed on FrontPanel-3 enabled devices. If the device is not running version 3 firmware, this method always returns true. This method always returns true if a device is not currently open.</p>
<dl class="section note"><dt>Note</dt><dd>This method has been DEPRECATED and will be removed from a future version of the API. The preferred method is <a class="el" href="classokCFrontPanel.html#a4650e9d343d3b80dd89ce658adaf8ab4" title="Fills a device information structure. ">GetDeviceInfo</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a4650e9d343d3b80dd89ce658adaf8ab4" title="Fills a device information structure. ">GetDeviceInfo</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9edd9efc80ca11772e71dbfe130d82ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool okCFrontPanel::IsOpen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><b>true</b> - Device is open. </dd>
<dd>
<b>false</b> - Device is not open. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa055c82bf61bae12f877dadf0907717"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool okCFrontPanel::IsRemote </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><b>true</b> If the device is connected to a remote server and, hence, operations with it have much higher latency, requiring the use of server-side scripts for acceptable performance. </dd></dl>

</div>
</div>
<a class="anchor" id="aaee61a8fb308b6a76c859d19dfd009c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool okCFrontPanel::IsTriggered </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>epAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">epAddr</td><td>The TriggerOut address to query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>A mask to apply to the trigger value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if any of the bits in the mask have triggered.</dd></dl>
<p>This method provides a way to find out if a particular bit (or bits) on a particular TriggerOut endpoint has triggered since the last call to <a class="el" href="classokCFrontPanel.html#a0f7a732026288b052c86ad656c5fc955" title="Reads Trigger Out endpoints. ">UpdateTriggerOuts()</a>. For example,</p>
<div class="fragment"><div class="line"><span class="comment">// First, query all XEM Trigger Outs.</span></div><div class="line">xem-&gt;UpdateTriggerOuts();</div><div class="line"><span class="comment">// Now, check the trigger on bit 7 of endpoint 0x71</span></div><div class="line"><span class="keywordflow">if</span> (<span class="keyword">true</span> == xem-&gt;IsTriggered(0x71, 0x80))</div><div class="line">   OnMachineDoneTrigger();</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a5d6ecf0224545b1160ca15de62795d27" title="Activates a given trigger. ">ActivateTriggerIn</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a0f7a732026288b052c86ad656c5fc955" title="Reads Trigger Out endpoints. ">UpdateTriggerOuts</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a206a26859fd2db3646dc748c815beeac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::LoadDefaultPLLConfiguration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>NoError - Operation complete successfully. </dd>
<dd>
DeviceNotOpen - Device is not open. </dd>
<dd>
UnsupportedFeature - The device does not have a supported PLL.</dd></dl>
<p>Configures the on-board PLL using the default configuration setup in the EEPROM. For a device with the Cypress CY22150 PLL, this is equivalent to: </p><div class="fragment"><div class="line"><a class="code" href="classokCPLL22150.html">okCPLL22150</a> pll;</div><div class="line">xem-&gt;GetEepromPLL22150Configuration(pll);</div><div class="line">xem-&gt;SetPLL22150Configuration(pll);</div></div><!-- fragment --><p>Similar equivalence exists for devices with the CY22393 PLL.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a5f9da76fb2f276145b575b23d573db92" title="Read PLL configuration from the on-board EEPROM (PLL22150). ">GetEepromPLL22150Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a7a650425713e28b66ddf83ef2c0863be" title="Read PLL configuration from the on-board EEPROM (PLL22393). ">GetEepromPLL22393Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a608f7220041afb1d2b4d7450b23063fa" title="Store the PLL configuration via the I2C bus (PLL22150). ">SetPLL22150Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a6a81c6463d9e9de21ec5732a07750d6a" title="Store the PLL configuration via the I2C bus (PLL22393). ">SetPLL22393Configuration</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8df2e32a316faa146a0047213bb77e6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::OpenBySerial </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Prefer to use <a class="el" href="classOpalKelly_1_1FrontPanelDevices.html#a4c76c5201c52a52a5886c4d20ea677e4">OpalKelly::FrontPanelDevices::Open()</a> in the new code, see <a class="el" href="migrate_fpdevices.html">Switching to OpalKelly::FrontPanelDevices</a> for more information.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The serial number of the device to open. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NoError - A device has been opened successfully. </dd>
<dd>
DeviceNotOpen - A device could not be opened.</dd></dl>
<p>Before any communication with the device can proceed, the device must be opened using this method. If the device had been already opened, it is closed automatically before opening it again.</p>
<p>A device is opened matching the given serial number string. If no serial number (or an empty string) is provided, then the first appropriate device is opened.</p>
<p><b>Python and Java Note:</b> To open the first available device, you must provide an empty string. </p>

<p>References <a class="el" href="structokTDeviceInfo.html#a8499afc882f767f8643e6528b2b002e8">okTDeviceInfo::productID</a>, and <a class="el" href="structokTDeviceInfo.html#a706fbcc56c0f1e44a8430c4a7cbb2b3b">okTDeviceInfo::productName</a>.</p>

</div>
</div>
<a class="anchor" id="a4accb11a5bfa48798e263aa2c4d9e977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long okCFrontPanel::ReadFromBlockPipeOut </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>epAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">epAddr</td><td>The address of the source Pipe Out. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the transfer (in bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>Block size (in bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A pointer to the transfer data buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read or ErrorCode (&lt;0) if the read failed. </dd>
<dd>
<b>InvalidEndpoint</b> - Invalid endpoint address specified. </dd>
<dd>
<b>InvalidBlockSize</b> - Block size specified is invalid. </dd>
<dd>
<b>Failed</b> - The operation failed. </dd>
<dd>
<b>Timeout</b> - The operation timed out. </dd>
<dd>
<b>UnsupportedFeature</b> - Length specified is invalid.</dd></dl>
<p>This method transfers data from a specified BlockPipeOut endpoint to the given buffer.</p>
<p>Block size is specified in bytes and are device-dependent:</p><ul>
<li><b>USB 2.0 FullSpeed</b> - Multiple of two [2..64]</li>
<li><b>USB 2.0 HighSpeed</b> - Multiple of two [2..1024]</li>
<li><b>USB 3.0 FullSpeed</b> - Power of two [16..64]</li>
<li><b>USB 3.0 HighSpeed</b> - Power of two [16..1024]</li>
<li><b>USB 3.0 SuperSpeed</b> - Power of two [16..16384]</li>
<li><b>PCIe:</b> - Not applicable</li>
</ul>
<p>Length is specified in bytes. Firmware restrictions put a limitation on the maximum length per transfer. However, this API will automatically perform multiple transfers, if required, to complete the full length. Length must be an integer multiple of the block size. The length must also be an integer multiple of a minimal transfer size according to the list below:</p><ul>
<li><b>USB 2.0:</b> Multiple of 2</li>
<li><b>USB 3.0:</b> Multiple of 16</li>
<li><b>PCIe:</b> Multiple of 8</li>
</ul>
<p><b>Performance Note:</b> Optimum bandwidth performance is achieved when <b>blockSize</b> is a power of two.</p>
<p><b>Python Note:</b> Within Python, the 'length' parameter is not used and the 'data' parameter is mutable type <b>bytearray</b>. For example,</p>
<div class="fragment"><div class="line">buf = bytearray(81920)</div><div class="line">xem.<a class="code" href="classokCFrontPanel.html#a4accb11a5bfa48798e263aa2c4d9e977">ReadFromBlockPipeOut</a>(0xa0, 1024, buf)</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a78d9da7ddea0a75c9ce408a64b14e51a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long okCFrontPanel::ReadFromPipeOut </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>epAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">epAddr</td><td>The address of the source Pipe Out. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the transfer (in bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A pointer to the transfer data buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read or ErrorCode (&lt;0) if the read failed. </dd>
<dd>
<b>InvalidEndpoint</b> - Invalid endpoint address specified. </dd>
<dd>
<b>InvalidBlockSize</b> - Block size specified is invalid. </dd>
<dd>
<b>Failed</b> - The operation failed. </dd>
<dd>
<b>Timeout</b> - The operation timed out. </dd>
<dd>
<b>UnsupportedFeature</b> - Length specified is invalid.</dd></dl>
<p>This method transfers data from a specified Pipe Out endpoint to the given buffer.</p>
<p>Length is specified in bytes. Firmware restrictions put a limitation on the maximum length per transfer. However, this API will automatically perform multiple transfers, if required, to complete the full length. Length must be an integer multiple of a minimal transfer size according to the list below:</p><ul>
<li><b>USB 2.0:</b> Multiple of 2</li>
<li><b>USB 3.0:</b> Multiple of 16</li>
<li><b>PCIe:</b> Multiple of 8</li>
</ul>
<p><b>Python Note:</b> Within Python, the 'length' parameter is not used and the 'data' parameter is mutable type <b>bytearray</b>. For example,</p>
<div class="fragment"><div class="line">buf = bytearray(15360)</div><div class="line">xem.<a class="code" href="classokCFrontPanel.html#a78d9da7ddea0a75c9ce408a64b14e51a">ReadFromPipeOut</a>(0xa0, buf)</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3b624f3bd41f874867f2becfdf776018"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::ReadI2C </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>I2C address of the target device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of data (in bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer receive data buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - Write has completed successfully. </dd>
<dd>
<b>DeviceNotOpen</b> - Communication with a XEM is not established. </dd>
<dd>
<b>CommunicationError</b> - Communication error with the firmware. </dd>
<dd>
<b>I2CRestrictedAddress</b> - Write to a restricted I2C address. </dd>
<dd>
<b>I2CBitError</b> - I2C bit error occurred. </dd>
<dd>
<b>I2CNack</b> - I2C device responded with NACK. </dd>
<dd>
<b>I2CUnknownStatus</b> - Unknown result status.</dd></dl>
<p>This method reads a string of bytes from the target I2C address. This transfer does not utilize the FPGA and can be done prior to configuration.</p>
<dl class="section note"><dt>Note</dt><dd>This method is only available for USB 2.0 devices. </dd></dl>

</div>
</div>
<a class="anchor" id="a230a2848017f7e86abe56a3144d3db0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::ReadRegister </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32 *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Register address </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Pointer to register data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - Operation completed successfully. </dd>
<dd>
<b>UnsupportedFeature</b> - Device does not support the RegisterBridge endpoint. </dd>
<dd>
<b>UnsupportedFeature</b> - FrontPanel is not enabled in the FPGA design. </dd>
<dd>
<b>DeviceNotOpen</b> - Device is not open.</dd></dl>
<p>Performs a single register read operation and puts the result into <b>data</b>.</p>
<p><b>Python Note:</b>In Python, the method is called as shown here: </p><div class="fragment"><div class="line">reg.data = device.ReadRegister(reg.address)</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The RegisterBridge endpoint is only supported on USB 3.0 devices.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a5969507a9b4333844d7a9c65ba871188" title="Reads a set of registers. ">ReadRegisters</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a7f4c4215b9515401faae6eb2afa5bdee" title="Writes a single register. ">WriteRegister</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#aadb3118557415653bce3bfdc435ccdf3" title="Writes a set of registers. ">WriteRegisters</a> </dd></dl>

<p>References <a class="el" href="classokCFrontPanel.html#a5969507a9b4333844d7a9c65ba871188">ReadRegisters()</a>.</p>

</div>
</div>
<a class="anchor" id="a5969507a9b4333844d7a9c65ba871188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::ReadRegisters </td>
          <td>(</td>
          <td class="paramtype">okTRegisterEntries &amp;&#160;</td>
          <td class="paramname"><em>regs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">regs</td><td>Vector of registers to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - Operation completed successfully. </dd>
<dd>
<b>UnsupportedFeature</b> - Device does not support the RegisterBridge endpoint. </dd>
<dd>
<b>UnsupportedFeature</b> - FrontPanel is not enabled in the FPGA design. </dd>
<dd>
<b>DeviceNotOpen</b> - Device is not open.</dd></dl>
<p>Performs multiple register reads at addresses provided by the elements of <em>regs</em> </p>
<div class="fragment"><div class="line"><span class="comment">// Read values at register addresses 0x00001234 and 0x00005678.</span></div><div class="line">okTRegisterEntries regs(2);</div><div class="line">regs[0].address = 0x1234;</div><div class="line">regs[1].address = 0x5678;</div><div class="line"><span class="keywordflow">if</span> (xem-&gt;ReadRegisters(regs) == okCFrontPanel::NoError) {</div><div class="line">    regs[0].data;   <span class="comment">// Value at 0x1234</span></div><div class="line">    regs[1].data;   <span class="comment">// Value at 0x5678</span></div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The RegisterBridge endpoint is only supported on USB 3.0 devices.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a230a2848017f7e86abe56a3144d3db0c" title="Reads a single register. ">ReadRegister</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a7f4c4215b9515401faae6eb2afa5bdee" title="Writes a single register. ">WriteRegister</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#aadb3118557415653bce3bfdc435ccdf3" title="Writes a set of registers. ">WriteRegisters</a> </dd></dl>

<p>Referenced by <a class="el" href="classokCFrontPanel.html#a230a2848017f7e86abe56a3144d3db0c">ReadRegister()</a>.</p>

</div>
</div>
<a class="anchor" id="aa99f02073f52d7c5e5e73a39130da434"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::RemoveCustomDevice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>productID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove a previously added custom device description.</p>
<p>This method can be used to forget about the device defined by a previous call to <a class="el" href="classokCFrontPanel.html#a6b4ed79e84fad3c7b4a34b5e22398439">AddCustomDevice()</a>. </p>

</div>
</div>
<a class="anchor" id="ad5494fe1f285b92b53317c1846e496f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::ResetFPGA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True always.</dd></dl>
<p>Performs a RESET of the FPGA internals. This requires that FrontPanel support be present in the FPGA design because the RESET signal actually comes from the FrontPanel Host Interface. </p>

</div>
</div>
<a class="anchor" id="ab5441f0e58ebcee9b14d6a6e935207f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::SetBTPipePollingInterval </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interval</td><td>Polling interval (in milliseconds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NoError errorcode if the interval was accepted.</dd></dl>
<p>At the completion of a BTPipeIn transfer, the host polls the hardware to confirm that all of the data has been consumed by the FPGA before returning from the function. The polling interval is set by this method.</p>
<p>The valid range for this interval is 1 to 100 milliseconds. Values outside this range cause the errorcode <b>Failed</b> to be returned. The default is 25 milliseconds. </p>

</div>
</div>
<a class="anchor" id="af5982edf22087334218e5f7f855be61e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void okCFrontPanel::SetDeviceID </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>A string containing the new Device ID.</td></tr>
  </table>
  </dd>
</dl>
<p>This method modifies the XEM Device ID string with the new string. The Device ID string is a user-programmable string of up to 32 characters that can be used to uniquely identify a particular XEM. The string will be truncated if it exceeds 32 characters. </p>

</div>
</div>
<a class="anchor" id="aab978515fcf82dd1ca0953b15fbf75cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::SetEepromPLL22150Configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classokCPLL22150.html">okCPLL22150</a> &amp;&#160;</td>
          <td class="paramname"><em>pll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pll</td><td>A reference to an <a class="el" href="classokCPLL22150.html" title="Container class which holds the appropriate configuration parameters for a Cypress 22150 PLL...">okCPLL22150</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NoError - Operation complete successfully. </dd>
<dd>
DeviceNotOpen - Device is not open.</dd></dl>
<p>This method programs the on-board XEM EEPROM with the PLL configuration in <b>pll</b>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a5f9da76fb2f276145b575b23d573db92" title="Read PLL configuration from the on-board EEPROM (PLL22150). ">GetEepromPLL22150Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a4b4ad78c98fb590695e54f8b68187df0" title="Read the PLL configuration via the I2C bus (PLL22150). ">GetPLL22150Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a206a26859fd2db3646dc748c815beeac" title="Configures the PLL from settings stored in EEPROM. ">LoadDefaultPLLConfiguration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a608f7220041afb1d2b4d7450b23063fa" title="Store the PLL configuration via the I2C bus (PLL22150). ">SetPLL22150Configuration</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad440632ca0eb4cfd6094e1fea1c19b63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::SetEepromPLL22393Configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classokCPLL22393.html">okCPLL22393</a> &amp;&#160;</td>
          <td class="paramname"><em>pll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pll</td><td>A reference to an <a class="el" href="classokCPLL22393.html" title="Container class which holds the appropriate configuration parameters for a Cypress 22393 PLL...">okCPLL22393</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NoError - Operation complete successfully. </dd>
<dd>
DeviceNotOpen - Device is not open.</dd></dl>
<p>This method programs the on-board XEM EEPROM with the PLL configuration in <b>pll</b>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a7a650425713e28b66ddf83ef2c0863be" title="Read PLL configuration from the on-board EEPROM (PLL22393). ">GetEepromPLL22393Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a04fc1588d583e5fbc2794a83a3a29041" title="Read the PLL configuration via the I2C bus (PLL22393). ">GetPLL22393Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a206a26859fd2db3646dc748c815beeac" title="Configures the PLL from settings stored in EEPROM. ">LoadDefaultPLLConfiguration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a6a81c6463d9e9de21ec5732a07750d6a" title="Store the PLL configuration via the I2C bus (PLL22393). ">SetPLL22393Configuration</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af458e6d190a371b1bf4f79e4e941a0d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::SetFPGAResetProfile </td>
          <td>(</td>
          <td class="paramtype">okEFPGAConfigurationMethod&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structokTFPGAResetProfile.html">okTFPGAResetProfile</a> *&#160;</td>
          <td class="paramname"><em>profile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Indicates which reset profile should be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">profile</td><td>Boot FPGA Reset Profile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - Write has completed successfully. </dd>
<dd>
<b>DeviceNotOpen</b> - Communication with a device is not established. </dd>
<dd>
<b>UnsupportedFeature</b> - Method not supported for this device. </dd>
<dd>
<b>InvalidParameter</b> - Invalid configuration method or NULL profile pointer. </dd>
<dd>
<b>Failed</b> - Request failed.</dd></dl>
<p>The Boot Reset Profile is the Reset Profile that defines how (and if) the firmware should configure the FPGA on boot and the sequence performed after configuration. If a valid Reset Profile is stored, the firmware will use that profile to boot and setup the FPGA at power-on.</p>
<p>The JTAG Reset Profile is the Reset Profile that defines the configuration sequence that should be followed after the FPGA is configured via JTAG. If a valid Reset Profile is stored, the firmware will method that profile to setup the FPGA if it detects completion of a JTAG-based configuration completion.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="structokTFPGAResetProfile.html">okTFPGAResetProfile</a> resetProfile;</div><div class="line">memset(&amp;p, 0, <span class="keyword">sizeof</span>(<a class="code" href="structokTFPGAResetProfile.html">okTFPGAResetProfile</a>));</div><div class="line">resetProfile.u32DoneWaitUS = 1000; <span class="comment">// Wait 1ms after DONE before Wire/Register setup</span></div><div class="line">resetProfile.u32WireInValues[0] = 0x000000f0;</div><div class="line">resetProfile.u32WireInValues[1] = 0x000000a0;</div><div class="line">resetProfile.u32NumRegisterEntries = 1;</div><div class="line">resetProfile.regEntries[0].u32Address = 0x1234;</div><div class="line">resetProfile.regEntries[0].u32Data = 0xAAAAAAAA;</div><div class="line">resetProfile.u32RegisterWaitUS = 10000;  <span class="comment">// Wait 1ms after Wire/Register setup</span></div><div class="line">resetProfile.u32ResetWaitUS = 10000;  <span class="comment">// Wait 1ms after RESET deasserts</span></div><div class="line">resetProfile.u32NumTriggerEntries = 2;</div><div class="line">resetProfile.trigEntries[0].u32Trigger = 0x40;</div><div class="line">resetProfile.trigEntries[0].u32Mask = 0x00000002;</div><div class="line">resetProfile.trigEntries[1].u32Trigger = 0x40;</div><div class="line">resetProfile.trigEntries[1].u32Mask = 0x00000002;</div><div class="line">resetProfile.u32Location = 16;  <span class="comment">// Bitfile stored at first user sector</span></div><div class="line">resetProfile.u32Length = 689900; <span class="comment">// Bitfile size</span></div><div class="line">dev-&gt;SetFPGAResetProfile(ok_FPGAConfigurationMethod_NVRAM, &amp;resetProfile);</div></div><!-- fragment --><p>An empty Reset Profile (with u32Length=0) specifies that an FPGA configuration is not to be loaded on boot. For example: </p><div class="fragment"><div class="line"><span class="comment">// Set an empty Reset Profile (u32Length=0) to prevent an FPGA configuration</span></div><div class="line"><span class="comment">// from being loaded at power-up.</span></div><div class="line"><a class="code" href="structokTFPGAResetProfile.html">okTFPGAResetProfile</a> p;</div><div class="line">memset(&amp;p, 0, <span class="keyword">sizeof</span>(<a class="code" href="structokTFPGAResetProfile.html">okTFPGAResetProfile</a>));</div><div class="line">dev-&gt;SetFPGAResetProfile(ok_FPGAConfigurationMethod_NVRAM, &amp;p));</div></div><!-- fragment --><p><b>Note:</b> This method is only available in the C/C++ DLL.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a69bbce82343535cb215d2d3bf460e7cd" title="Retrieve the current FPGA configuration reset profile for the given method. ">GetFPGAResetProfile</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a608f7220041afb1d2b4d7450b23063fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::SetPLL22150Configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classokCPLL22150.html">okCPLL22150</a> &amp;&#160;</td>
          <td class="paramname"><em>pll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pll</td><td>A reference to an <a class="el" href="classokCPLL22150.html" title="Container class which holds the appropriate configuration parameters for a Cypress 22150 PLL...">okCPLL22150</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NoError - Operation complete successfully. </dd>
<dd>
DeviceNotOpen - Device is not open.</dd></dl>
<p>Configures the on-board PLL via the I2C bus using the configuration information in the <b>pll</b> object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a5f9da76fb2f276145b575b23d573db92" title="Read PLL configuration from the on-board EEPROM (PLL22150). ">GetEepromPLL22150Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a4b4ad78c98fb590695e54f8b68187df0" title="Read the PLL configuration via the I2C bus (PLL22150). ">GetPLL22150Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a206a26859fd2db3646dc748c815beeac" title="Configures the PLL from settings stored in EEPROM. ">LoadDefaultPLLConfiguration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#aab978515fcf82dd1ca0953b15fbf75cb" title="Store PLL configuration on the on-board EEPROM (PLL22150). ">SetEepromPLL22150Configuration</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6a81c6463d9e9de21ec5732a07750d6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::SetPLL22393Configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classokCPLL22393.html">okCPLL22393</a> &amp;&#160;</td>
          <td class="paramname"><em>pll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pll</td><td>A reference to an <a class="el" href="classokCPLL22393.html" title="Container class which holds the appropriate configuration parameters for a Cypress 22393 PLL...">okCPLL22393</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NoError - Operation complete successfully. </dd>
<dd>
DeviceNotOpen - Device is not open.</dd></dl>
<p>Configures the on-board PLL via the I2C bus using the configuration information in the <b>pll</b> object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a7a650425713e28b66ddf83ef2c0863be" title="Read PLL configuration from the on-board EEPROM (PLL22393). ">GetEepromPLL22393Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a04fc1588d583e5fbc2794a83a3a29041" title="Read the PLL configuration via the I2C bus (PLL22393). ">GetPLL22393Configuration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a206a26859fd2db3646dc748c815beeac" title="Configures the PLL from settings stored in EEPROM. ">LoadDefaultPLLConfiguration</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#ad440632ca0eb4cfd6094e1fea1c19b63" title="Store PLL configuration on the on-board EEPROM (PLL22393). ">SetEepromPLL22393Configuration</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8bb9f63c7cfe315781f52d289ca6c2bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void okCFrontPanel::SetTimeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout duration specified in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<p>This method sets the timeout value used by USB transactions when communicating with the target device. Note that this is not necessarily the timeout for a particular API call. By default, the timeout is set to 10 seconds).</p>
<p>Note that a timeout is not always provided by the underlying calls nor by the operating system. Most generally, the timeout will apply to pipe transfers and FPGA configuration transfers. </p>

</div>
</div>
<a class="anchor" id="a74f8b4b37ccc57dd72b5b739bbc45766"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::SetWireInValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>mask</em> = <code>0xffffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>The address of the WireIn endpoint to update. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The new value of the WireIn. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>A mask to apply to the new value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - Operation completed successfully. </dd>
<dd>
<b>InvalidEnpoint</b> - Endpoint address outside the range for WireIn. </dd>
<dd>
<b>DeviceNotOpen</b> - Device is not open.</dd></dl>
<p>WireIn endpoint values are stored internally and updated when necessary by calling <a class="el" href="classokCFrontPanel.html#a50a5ae9f0bcd08b5ebc7f75612c256f5" title="Transfers current Wire In values to the FPGA. ">UpdateWireIns()</a>. The values are updated on a per-endpoint basis by calling this method. In addition, specific bits may be updated independent of other bits within an endpoint by using the optional <b>mask</b>.</p>
<div class="fragment"><div class="line"><span class="comment">// Update Wire In 0x03 with the value 0x35.</span></div><div class="line">xem-&gt;SetWireInValue(0x03, 0x35);</div><div class="line"><span class="comment">// Update only bit 3 of Wire In 0x07 with a 1.</span></div><div class="line">xem-&gt;SetWireInValue(0x07, 0x04, 0x04);</div><div class="line"><span class="comment">// Commit the updates to the XEM.</span></div><div class="line">xem-&gt;UpdateWireIns();</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#ace377ac73c390322fd0832b774654920" title="Gets the value of a particular Wire In from the internal wire data structure. ">GetWireInValue</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a179f9ffba19235bdd314dd9b2efd3054" title="Gets the value of a particular Wire Out from the internal wire data structure. ">GetWireOutValue</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a50a5ae9f0bcd08b5ebc7f75612c256f5" title="Transfers current Wire In values to the FPGA. ">UpdateWireIns</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#afb4f41ee15d213d76dddc8b589b527b0" title="Transfers current Wire Out values from the FPGA. ">UpdateWireOuts</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0f7a732026288b052c86ad656c5fc955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::UpdateTriggerOuts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is called to query the XEM to determine if any TriggerOuts have been activated since the last call.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a5d6ecf0224545b1160ca15de62795d27" title="Activates a given trigger. ">ActivateTriggerIn</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#aaee61a8fb308b6a76c859d19dfd009c8" title="Returns true if the trigger has been triggered. ">IsTriggered</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a50a5ae9f0bcd08b5ebc7f75612c256f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::UpdateWireIns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is called after all WireIn values have been updated using <a class="el" href="classokCFrontPanel.html#a74f8b4b37ccc57dd72b5b739bbc45766" title="Sets a wire value in the internal wire data structure. ">SetWireInValue()</a>. The latter call merely updates the values held within a data structure inside the class. This method actually commits the changes to the XEM simultaneously so that all wires will be updated at the same time.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a179f9ffba19235bdd314dd9b2efd3054" title="Gets the value of a particular Wire Out from the internal wire data structure. ">GetWireOutValue</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#ace377ac73c390322fd0832b774654920" title="Gets the value of a particular Wire In from the internal wire data structure. ">GetWireInValue</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a74f8b4b37ccc57dd72b5b739bbc45766" title="Sets a wire value in the internal wire data structure. ">SetWireInValue</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#afb4f41ee15d213d76dddc8b589b527b0" title="Transfers current Wire Out values from the FPGA. ">UpdateWireOuts</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afb4f41ee15d213d76dddc8b589b527b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::UpdateWireOuts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is called to request the current state of all WireOut values from the XEM. All wire outs are captured and read at the same time.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a179f9ffba19235bdd314dd9b2efd3054" title="Gets the value of a particular Wire Out from the internal wire data structure. ">GetWireOutValue</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#ace377ac73c390322fd0832b774654920" title="Gets the value of a particular Wire In from the internal wire data structure. ">GetWireInValue</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a74f8b4b37ccc57dd72b5b739bbc45766" title="Sets a wire value in the internal wire data structure. ">SetWireInValue</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a50a5ae9f0bcd08b5ebc7f75612c256f5" title="Transfers current Wire In values to the FPGA. ">UpdateWireIns</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a20b8caa652f5ace0343c6784de8478db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::WriteI2C </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>I2C address of the target device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of data (in bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to data to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - Write has completed successfully. </dd>
<dd>
<b>DeviceNotOpen</b> - Communication with a XEM is not established. </dd>
<dd>
<b>CommunicationError</b> - Communication error with the firmware. </dd>
<dd>
<b>I2CRestrictedAddress</b> - Write to a restricted I2C address. </dd>
<dd>
<b>I2CBitError</b> - I2C bit error occurred. </dd>
<dd>
<b>I2CNack</b> - I2C device responded with NACK. </dd>
<dd>
<b>I2CUnknownStatus</b> - Unknown result status.</dd></dl>
<p>This method writes a string of bytes to the target I2C address. This transfer does not utilize the FPGA and can be done prior to configuration.</p>
<dl class="section note"><dt>Note</dt><dd>This method is only available for USB 2.0 devices. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f4c4215b9515401faae6eb2afa5bdee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::WriteRegister </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Register address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to register data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - Operation completed successfully. </dd>
<dd>
<b>UnsupportedFeature</b> - Device does not support the RegisterBridge endpoint. </dd>
<dd>
<b>UnsupportedFeature</b> - FrontPanel is not enabled in the FPGA design. </dd>
<dd>
<b>DeviceNotOpen</b> - Device is not open.</dd></dl>
<p>Performs a single register write operation.</p>
<dl class="section note"><dt>Note</dt><dd>The RegisterBridge endpoint is only supported on USB 3.0 devices.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a230a2848017f7e86abe56a3144d3db0c" title="Reads a single register. ">ReadRegister</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a5969507a9b4333844d7a9c65ba871188" title="Reads a set of registers. ">ReadRegisters</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#aadb3118557415653bce3bfdc435ccdf3" title="Writes a set of registers. ">WriteRegisters</a> </dd></dl>

<p>References <a class="el" href="classokCFrontPanel.html#aadb3118557415653bce3bfdc435ccdf3">WriteRegisters()</a>.</p>

</div>
</div>
<a class="anchor" id="aadb3118557415653bce3bfdc435ccdf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">okCFrontPanel::ErrorCode okCFrontPanel::WriteRegisters </td>
          <td>(</td>
          <td class="paramtype">const okTRegisterEntries &amp;&#160;</td>
          <td class="paramname"><em>regs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">regs</td><td>Vector of registers to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>NoError</b> - Operation completed successfully. </dd>
<dd>
<b>UnsupportedFeature</b> - Device does not support the RegisterBridge endpoint. </dd>
<dd>
<b>UnsupportedFeature</b> - FrontPanel is not enabled in the FPGA design. </dd>
<dd>
<b>DeviceNotOpen</b> - Device is not open.</dd></dl>
<p>Writes values of multiple registers at once.</p>
<div class="fragment"><div class="line"><span class="comment">// Write values to register addresses 0x00001234 and 0x00005678.</span></div><div class="line">okTRegisterEntries regs(2);</div><div class="line">regs[0].address = 0x1234;</div><div class="line">regs[0].data    = 0xABCD;   <span class="comment">// Value to write to 0x1234</span></div><div class="line">regs[1].address = 0x5678;</div><div class="line">regs[1].data    = 0xF00D;   <span class="comment">// Value to write to 0x5678</span></div><div class="line">xem-&gt;WriteRegisters(regs);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The RegisterBridge endpoint is only supported on USB 3.0 devices.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classokCFrontPanel.html#a230a2848017f7e86abe56a3144d3db0c" title="Reads a single register. ">ReadRegister</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a5969507a9b4333844d7a9c65ba871188" title="Reads a set of registers. ">ReadRegisters</a> </dd>
<dd>
<a class="el" href="classokCFrontPanel.html#a7f4c4215b9515401faae6eb2afa5bdee" title="Writes a single register. ">WriteRegister</a> </dd></dl>

<p>Referenced by <a class="el" href="classokCFrontPanel.html#a7f4c4215b9515401faae6eb2afa5bdee">WriteRegister()</a>.</p>

</div>
</div>
<a class="anchor" id="a1046c9a36a5442329ae20e278e2a92f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long okCFrontPanel::WriteToBlockPipeIn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>epAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">epAddr</td><td>The address of the destination Pipe In. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the transfer (in bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>Block size (in bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A pointer to the transfer data buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written or ErrorCode (&lt;0) if the write failed. </dd>
<dd>
<b>InvalidEndpoint</b> - Invalid endpoint address specified. </dd>
<dd>
<b>InvalidBlockSize</b> - Block size specified is invalid. </dd>
<dd>
<b>Failed</b> - The operation failed. </dd>
<dd>
<b>Timeout</b> - The operation timed out. </dd>
<dd>
<b>UnsupportedFeature</b> - Length specified is invalid.</dd></dl>
<p>This method transfers a specified buffer of data to the given BlockPipeIn endpoint. If the transfer fails, an ErrorCode is returned. A return value less than 0 indicates an error situation.</p>
<p>Block size is specified in bytes and are device-dependent:</p><ul>
<li><b>USB 2.0 FullSpeed</b> - Multiple of two [2..64]</li>
<li><b>USB 2.0 HighSpeed</b> - Multiple of two [2..1024]</li>
<li><b>USB 3.0 FullSpeed</b> - Power of two [16..64]</li>
<li><b>USB 3.0 HighSpeed</b> - Power of two [16..1024]</li>
<li><b>USB 3.0 SuperSpeed</b> - Power of two [16..16384]</li>
<li><b>PCIe:</b> - Not applicable</li>
</ul>
<p>Length is specified in bytes. Firmware restrictions put a limitation on the maximum length per transfer. However, this API will automatically perform multiple transfers, if required, to complete the full length. Length must be an integer multiple of the block size. The length must also be an integer multiple of a minimal transfer size according to the list below:</p><ul>
<li><b>USB 2.0:</b> Multiple of 2</li>
<li><b>USB 3.0:</b> Multiple of 16</li>
<li><b>PCIe:</b> Multiple of 8</li>
</ul>
<p><b>Python Note:</b> Within Python, the 'length' parameter is not used and the 'data' parameter is of the mutable type <b>bytearray</b>. For example,</p>
<div class="fragment"><div class="line">buf = bytearray(4096)</div><div class="line">xem.<a class="code" href="classokCFrontPanel.html#a1046c9a36a5442329ae20e278e2a92f5">WriteToBlockPipeIn</a>(0x80, 512, buf)</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab5a48ebe66a14414455d6b5de7f593cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long okCFrontPanel::WriteToPipeIn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>epAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">epAddr</td><td>The address of the destination Pipe In. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the transfer (in bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A pointer to the transfer data buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written or ErrorCode (&lt;0) if the write failed. </dd>
<dd>
<b>InvalidEndpoint</b> - Invalid endpoint address specified. </dd>
<dd>
<b>InvalidBlockSize</b> - Block size specified is invalid. </dd>
<dd>
<b>Failed</b> - The operation failed. </dd>
<dd>
<b>Timeout</b> - The operation timed out. </dd>
<dd>
<b>UnsupportedFeature</b> - Length specified is invalid.</dd></dl>
<p>This method transfers a specified buffer of data to the given Pipe In endpoint. If the transfer fails, an ErrorCode is returned. A return value less than 0 indicates an error situation.</p>
<p>Length is specified in bytes. Firmware restrictions put a limitation on the maximum length per transfer. However, this API will automatically perform multiple transfers, if required, to complete the full length. Length must be an integer multiple of a minimal transfer size according to the list below:</p><ul>
<li><b>USB 2.0:</b> Multiple of 2</li>
<li><b>USB 3.0:</b> Multiple of 16</li>
<li><b>PCIe:</b> Multiple of 8</li>
</ul>
<p><b>Python Note:</b> Within Python, the 'length' parameter is not used and the 'data' parameter is mutable type <b>bytearray</b>. For example,</p>
<div class="fragment"><div class="line">buf = bytearray(81920)</div><div class="line">xem.<a class="code" href="classokCFrontPanel.html#ab5a48ebe66a14414455d6b5de7f593cf">WriteToPipeIn</a>(0x80, buf)</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<hr size="1">
<center><small>Copyright (c) 2005-2017  Opal Kelly Incorporated</small></center>
</body>
</html>
